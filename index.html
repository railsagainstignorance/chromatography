<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Chromatography</title>
  <style>
  .blotting-paper {
    border-width: 1px;
    border-color: lightgrey;
    border-style: solid;

    box-shadow: 10px 10px 5px #888888;

    background-color: white;
  }
  </style>
  <script src="assets/cellauto.min.js"></script>
  <script>
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  </script>
  <script>
  const Chroma = (function(){

    const DYES = [
      {
        name: 'red',
          Rf: 0.2,  // propensity to go with the flow
          Rd: 0.07, // propensity to 'bleed' if no flow
          RGBPattern: [1.0, 0, 0], // how to read it's value from/to RGB triple
      },
      {
        name: 'green',
          Rf: 0.3,
          Rd: 0.075,
          RGBPattern: [0, 1.0, 0],
      },
      {
        name: 'blue',
          Rf: 0.4,
          Rd: 0.06,
          RGBPattern: [0, 0, 1.0],
      },
    ];

    {
      // check internal consistency of Rf and Rd

      let numDirections = 8;

      for( let dye of DYES ){
        if ( (dye.Rf + (numDirections * dye.Rd)) > 1.0 ) {
          throw new Error(`ERROR: Rf + numDirections*Rd >1.0 for name=${dye.name}, Rf=${dye.Rf}, Rd=${dye.Rd}, numDirections=${numDirections}`);
        }
      }
    }

    DYES.RGBMaximum = 253;
    DYES.volumeMultiplier = 10.0;

    DYES.splitRgbaPixelIntoDyes = function(rgba) {
      // assume rgba is [R,G,B, A], each 0-255
      // use A to dilute dye amounts
      // assume full white [255,255,255], or full transparent, has no dyes at all
      // clip (to full transparent) if min RGB > threshold
      // return array of dye amounts, min 0, max 1.0

      var dyeAmounts = new Array(this.length);

      if ( rgba[3]==0 ) {
        dyeAmounts.fill(0);
      } else if (rgba[0]==255 && rgba[1]==255 && rgba[2]==255) {
        dyeAmounts.fill(0);
      } else if (Math.min(rgba[0], rgba[1], rgba[2]) >= this.RGBMaximum ){
        dyeAmounts.fill(0);
      } else {
        for (var d = 0; d < this.length; d++) {
          let tot = 0;
          for (var i = 0; i < 3; i++) {
            tot = tot + (rgba[i] * this[d].RGBPattern[i] / 255);
          }
          tot = tot * (rgba[3] / 255);
          // dyeAmounts[d] = Math.min(tot, 1.0);
          dyeAmounts[d] = tot;
        }
      }
      return dyeAmounts;
    }

    DYES.combineDyesIntoRgbaPixel = function(dyeAmounts) {
      // return [R, G, B, A]
      // assume no dyes => full transparent

      // calc 0-1.0 range, then convert to 0-255 later
      var rgba01 = new Array(3).fill(0);

      for (var d = 0; d < this.length; d++) {
        for (var i = 0; i < 3; i++) {
          rgba01[i] = rgba01[i] + (dyeAmounts[d] * this[d].RGBPattern[i]);
        }
      }

      var maxRGB01 = Math.max.apply(null, rgba01);
      if (maxRGB01 > 1.0) {
        rgba01 = rgba01.map(c => {return c/maxRGB01});
        maxRGB01 = 1.0;
      }
      rgba01.push(maxRGB01);

      var rgba = rgba01.map(c => {return (c>1.0)? 255 : Math.floor(c * 255);});
      return rgba;
    }

    {
      // test the conversion from RGBA Pixels to dyes, and back
      let testRgbaPixels = [
        [ [  0,  0,  0,  0], [  0,  0,  0,  0], 'transparent --> transparent' ],
        [ [ 10, 20, 30,  0], [  0,  0,  0,  0], 'transparent --> transparent' ],
        [ [255,255,255,255], [  0,  0,  0,  0], 'white --> transparent' ],
        [ [255,  0,  0,255], [255,  0,  0,255], 'full red --> full red' ],
        [ [  0,255,  0,255], [  0,255,  0,255], 'full green --> full green' ],
        [ [  0,  0,255,255], [  0,  0,255,255], 'full blue --> full blue' ],
        [ [255,255,  0,255], [255,255,  0,255], 'full red+green --> full red+green' ],
        [ [ 10, 11, 12,255], [ 10, 11, 12, 12], 'mix of RGB --> mix of RGB, more transparent' ],
        [ [ 10, 20, 30, 51], [  2,  4,  6,006], 'mix of RGB + weak A --> mix of RGB, more transparent'],
      ];

      for (var p = 0; p < testRgbaPixels.length; p++) {
        let fromPixel = testRgbaPixels[p][0];
        let toPixel   = testRgbaPixels[p][1];
        let dyeAmounts = DYES.splitRgbaPixelIntoDyes( fromPixel );
        let outputPixel  = DYES.combineDyesIntoRgbaPixel( dyeAmounts );
        for (var i = 0; i < fromPixel.length; i++) {
          if (toPixel[i] !== outputPixel[i]) {
            throw new Error(`Error: in testing Dye Conversion: converting pixel to dyes and back: ${testRgbaPixels[p][2]}: fromPixel=${fromPixel}, toPixel=${toPixel}, but outputPixel=${outputPixel}, and dyeAmounts=${dyeAmounts}`);
          }
        }
      }
    }

    DYES.convertImageDataIntoGridOfDyeAmounts = function(imageData, volumeMultiplier=1.0){
      const data = imageData.data;
      const grid = [];

      for (var x = 0; x < imageData.width; x++) {
        let col = [];
        grid.push(col);
        for (var y = 0; y < imageData.height; y++) {
          let imageDataCellIndex = 4 * (x + (y * imageData.width));
          let rgba = data.slice(imageDataCellIndex, imageDataCellIndex + 4);
          let dyeAmounts = this.splitRgbaPixelIntoDyes(rgba);
          dyeAmounts = dyeAmounts.map(da => { return da * volumeMultiplier; });
          col.push(dyeAmounts);
        }
      }

      return grid;
    }

    DYES.writeGridOfDyeAmountsToImageData = function(grid, imageData){
      if ((imageData.width !== grid.length) || (imageData.height !== grid[0].length)) {
        throw new Error(`Error: mismatch found between size of grid and imageData`);
      }
      const data = imageData.data;

      for (var x=0; x<imageData.width; x++) {
        for (var y=0; y<imageData.height; y++) {
          var dyeAmounts = grid[x][y];
          var rgba = this.combineDyesIntoRgbaPixel(dyeAmounts);
          var dataCellIndex = 4 * (x + (y * imageData.width));
          for (var i = 0; i < 4; i++) {
            data[dataCellIndex+i] = rgba[i];
          }
        }
      }

      return imageData;
    }

    {
      // test conversion imagaData into grid of dye amounts, and back
      var height = 2;
      var width  = 2;
      var numPixels = width * height;
      var testCanvas = document.createElement('canvas');
      testCanvas.width = width;
      testCanvas.height = height;
      var testContext = testCanvas.getContext('2d');

      // specify test imageData examples

      var testDatas = [
          {
            from: [
            [255,255,255,255], [255,255,255,255],
            [255,255,255,255], [255,255,255,255]
            ],
            target: [
            [  0,  0,  0,  0], [  0,  0,  0,  0],
            [  0,  0,  0,  0], [  0,  0,  0,  0]
            ],
            desc: 'all white --> all white'
          },
          {
            from: [
              [255,255,255,  0], [ 10, 11, 12,  0],
              [  0,  0,  0,255], [  0,  0,  0,  0]
            ],
            target: [
              [  0,  0,  0,  0], [  0,  0,  0,  0],
              [  0,  0,  0,  0], [  0,  0,  0,  0]
            ],
            desc: 'mix of non-color --> all white'
          },
          {
            from: [
              [ 10, 11, 12,255], [255,254,253,255],
              [100,100,100,255], [255,255,255,255]
            ],
            target: [
              [ 10, 11, 12, 12], [  0,  0,  0,  0],
              [100,100,100,100], [  0,  0,  0,  0]
            ],
            desc: 'mix of colors + full A --> mix of colors + full A'
          },
      ];

      for (var t = 0; t < testDatas.length; t++) {
        if (testDatas[t].from.length !== testDatas[t].target.length) {
          throw new Error(`ERROR: in testing Grid Conversion: ${testDatas[t].desc}: inconsistent from and target datas: t=${t}, testDatas[t]=${testDatas[t]}`);
        }
        // create imageData
        var fromImageData = testContext.createImageData(width, height);
        var data = fromImageData.data;
        for (var p = 0; p < numPixels; p++) {
          for (var i = 0; i < 4; i++) {
            data[(4 * p) + i] = testDatas[t].from[p][i];
          }
        }
        // convert to dye amounts
        var gridOfDyeAmounts = DYES.convertImageDataIntoGridOfDyeAmounts(fromImageData);
        // convert to imageData
        var outputImageData = DYES.writeGridOfDyeAmountsToImageData(gridOfDyeAmounts, testContext.createImageData(width, height));
        // compare
        if (fromImageData.data.length !== outputImageData.data.length) {
          throw new Error(`ERROR: in testing Grid Conversion: fromImageData.data.length(${fromImageData.data.length}) !== outputImageData.data.length(${outputImageData.data.length})`);
        }
        var outputData = outputImageData.data;
        var targetData = testDatas[t].target;
        // compare pixels
        for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
            let xywidth = (x + (y * width));
            let pixelIndex = 4 * xywidth;
            for (var i = 0; i < 4; i++) {
              if (outputData[pixelIndex + i] !== targetData[xywidth][i]) {
                throw new Error(`ERROR: in testing Grid Conversion: ${testDatas[t].desc}: x=${x}, y=${y}, i=${i},
      outputData[pixelIndex + i]=${outputData[pixelIndex + i]},
      targetData[xywidth][i]=${targetData[xywidth][i]},
      outputData=${outputData},
      targetData=${targetData}`);
              }
            }
          }
        }
      }
    }

    function createWorldOfBlottingPaperAndDyes(width, height, gridOfDyeAmounts) {
    	world = new CAWorld({
    		width: Math.floor(width),
    		height: Math.floor(height),
    	});

      world.flowRate = 1.0;
      world.bleedDirections = [world.LEFT, world.RIGHT, world.BOTTOM, world.TOP, world.TOPLEFT, world.TOPRIGHT, world.BOTTOMLEFT, world.BOTTOMRIGHT];

    	world.registerCellType('paper', {
    		getDyeAmounts: function () {
          return this.value;
    		},
    		process: function (neighbors) {
          // do clever flow stuff here

          for (var d = 0; d < DYES.length; d++) {
            const  flowAmount = this.value[d] * DYES[d].Rf * world.flowRate;
            const bleedAmount = this.value[d] * DYES[d].Rd;

            this.next[d] = this.value[d];

            // some of this cell's dyes will flow to BOTTOM
            if (neighbors[world.BOTTOM.index] !== null) {
              this.next[d] = this.next[d] - flowAmount;
            }
            // this cell will receive a flow from TOP
            if (neighbors[world.TOP.index] !== null) {
              this.next[d] = this.next[d] + (neighbors[world.TOP.index].value[d] * DYES[d].Rf);
            }

            // this cell will receive a bleed from, and bleed to, each of the directions
            for( let direction of world.bleedDirections ){
              if (neighbors[direction.index] !== null) {
                this.next[d] = this.next[d] + (neighbors[direction.index].value[d] * DYES[d].Rd);
                this.next[d] = this.next[d] - bleedAmount;
              }
            }
          }

          // // experiment with simple fading
          // for (var d = 0; d < DYES.length; d++) {
          //   this.next[d] = this.value[d] * (1 - DYES[d].Rf);
          // }

    			return true;
    		},
    		reset: function () {
  				this.prev  = this.value;
  				this.value = this.next;
          this.next  = this.next.slice(0);
    			return true;
    		}
    	}, function (x,y) {
    		//init
        this.value = gridOfDyeAmounts[y][x].slice(0);
        this.prev = this.value.slice(0);
    		this.next = this.value.slice(0);
    	});

    	world.initialize([
    		{ name: 'paper', distribution: 100 }
    	]);

    	return world;
    }

    function convertWorldGridToGridOfDyeAmounts(worldGrid){
      var gridOfDyeAmounts = [];

      for (var x = 0; x < worldGrid.length; x++) {
        var col = [];
        gridOfDyeAmounts.push(col);
        for (var y = 0; y < worldGrid[0].length; y++) {
          col.push( worldGrid[x][y].getDyeAmounts());
        }
      }

      return gridOfDyeAmounts;
    }

    function createPaper(canvas, maxIterations=100){
        function addSolvent() {
          const context = canvas.getContext('2d');
          console.log(`canvas.width=${canvas.width}, canvas.height=${canvas.height}`);
          const imageData = context.getImageData(0,0,canvas.width,canvas.height);
          const gridOfDyeAmounts = DYES.convertImageDataIntoGridOfDyeAmounts(imageData, DYES.volumeMultiplier);
          const world = createWorldOfBlottingPaperAndDyes(imageData.width, imageData.height, gridOfDyeAmounts);
          console.log(`world.width=${world.width}, world.height=${world.height}`);

          var numIterations=1;

          function iterateAndDisplayWorld(){
            // console.log(`world iteration=${numIterations} of ${maxIterations}`);
            world.step();
            let gridOfDyeAmounts = convertWorldGridToGridOfDyeAmounts(world.grid);
            DYES.writeGridOfDyeAmountsToImageData(gridOfDyeAmounts, imageData);
            context.putImageData(imageData, 0, 0);

            numIterations = numIterations + 1;
            if (numIterations < maxIterations) {
              window.requestAnimationFrame(iterateAndDisplayWorld);
            } else {
              console.log(`ending on world iteration=${numIterations} of ${maxIterations}`);
              window.dispatchEvent( new Event('StopRecording') );
            }
          }

          iterateAndDisplayWorld();
        }

        return {
          run: addSolvent
        }
    }

    return {
      create: createPaper
    }
  })();
  </script>
</head>

<body>
  <h1>Chromatography</h1>

    <canvas class="blotting-paper" id="myCanvas" width="400" height="400"></canvas>

  <script>
  (function(){
    const codeVersion = '2-0'; // affects filename of recording
    const maxIterations = 10;

    const canvas = document.getElementById('myCanvas');
    const context = canvas.getContext('2d');

    {
      /* set up the recording of the canvas animations */
      const frameRate = 15;
      const stream = canvas.captureStream(frameRate);
      const mimeType = 'video/webm';
      const options = {mimeType: mimeType};
      const mediaRecorder = new MediaRecorder(stream, options);
      mediaRecorder.ondataavailable = download;
      mediaRecorder.start();
      window.addEventListener('StopRecording', e => { mediaRecorder.stop(); })
      const recordedFile = `chromatography-experiment.${codeVersion}.webm`;
      function download(event) {
        const videoData = [ event.data ];
        const blob = new Blob(videoData, {
          type: mimeType
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        document.body.appendChild(a);
        a.style = 'display: none';
        a.href = url;
        a.download = recordedFile;
        a.click();
        window.URL.revokeObjectURL(url);
      }
    }

    {
      /* start the CA when the image has loaded */
      const imageObj = new Image();

      imageObj.onload = function() {
        context.drawImage(imageObj, 0, 0);
        var paper = Chroma.create(canvas, maxIterations);
        window.setTimeout(paper.run, 100);
      };
      // imageObj.src = 'assets/profile_400x400.jpg';
      imageObj.src = 'assets/splodge.png';
    }
  })();
  </script>
</body>
</html>
