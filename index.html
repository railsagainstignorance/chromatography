<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Chromatography</title>
  <style>
  .blotting-paper {
    border-width: 1px;
    border-color: lightgrey;
    border-style: solid;

    box-shadow: 10px 10px 5px #888888;

    background-color: white;
  }
  </style>
  <script src="assets/cellauto.min.js"></script>
  <script>
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  </script>
  <script>
  const Chroma = (function(){

    const DYES = [
      {
        name: 'red',
          Rf: 0.2,  // propensity to go with the flow
          Rd: 0.07, // propensity to 'bleed' if no flow
          RGBPattern: [1.0, 0, 0], // how to read it's value from/to RGB triple
      },
      {
        name: 'green',
          Rf: 0.3,
          Rd: 0.075,
          RGBPattern: [0, 1.0, 0],
      },
      {
        name: 'blue',
          Rf: 0.4,
          Rd: 0.06,
          RGBPattern: [0, 0, 1.0],
      },
    ];

    {
      // check internal consistency of Rf and Rd

      let numDirections = 8;

      for( let dye of DYES ){
        if ( (dye.Rf + (numDirections * dye.Rd)) > 1.0 ) {
          throw new Error(`ERROR: Rf + numDirections*Rd >1.0 for name=${dye.name}, Rf=${dye.Rf}, Rd=${dye.Rd}, numDirections=${numDirections}`);
        }
      }
    }

    DYES.RGBMaximum = 253;

    DYES.newEmptyDyeAmounts = function() {
      return new Array(this.length).fill(0);
    }

    DYES.copyAmounts = function(from, to){
      for (var i = 0; i < this.length; i++) {
        to[i] = from[i];
      }
    }

    DYES.addAmounts = function(from, to){
      for (var i = 0; i < this.length; i++) {
        to[i] = to[i] + from[i];
      }
    }

    DYES.combineDyesIntoRgbaPixel = function(dyeAmounts) {
      // return [R, G, B, A]
      // assume no dyes => full white

      // calc 0-1.0 range, then convert to 0-255 later
      var rgba01 = new Array(3).fill(0);

      for (var d = 0; d < this.length; d++) {
        for (var i = 0; i < 3; i++) {
          rgba01[i] = rgba01[i] + (dyeAmounts[d] * this[d].RGBPattern[i]);
        }
      }

      var maxRGB01 = Math.max.apply(null, rgba01);
      if (maxRGB01 > 1.0) {
        rgba01 = rgba01.map(c => {return c/maxRGB01});
        maxRGB01 = 1.0;
      }
      rgba01.push(maxRGB01);
      if (maxRGB01 == 0) {
        rgba01.fill(1.0);
      }

      var rgba = rgba01.map(c => {return (c>1.0)? 255 : Math.floor(c * 255);});
      return rgba;
    }

    DYES.writeGridOfDyeAmountsToImageData = function(grid, imageData){
      if ((imageData.width !== grid.length) || (imageData.height !== grid[0].length)) {
        throw new Error(`Error: mismatch found between size of grid and imageData`);
      }
      const data = imageData.data;
      for (var x=0; x<imageData.width; x++) {
        for (var y=0; y<imageData.height; y++) {
          var dyeAmounts = grid[x][y];
          var rgba = this.combineDyesIntoRgbaPixel(dyeAmounts);
          var dataCellIndex = 4 * (x + (y * imageData.width));
          for (var i = 0; i < 4; i++) {
            data[dataCellIndex+i] = rgba[i];
          }
        }
      }
      return imageData;
    }

    //------------

    var PaperSpot = function(dyeAmounts, waterAmount){
      this.dyeAmounts  =  (dyeAmounts)? dyeAmounts.slice(0) : DYES.newEmptyDyeAmounts();
      this.waterAmount = (waterAmount)?        waterAmounts : 0;
    }

    PaperSpot.prototype = (function () {
      /* private members */
      let maxWaterCapacity = 1;
      /* public members */
      return {
           MaxWaterCapacity: maxWaterCapacity,
        WaterAbsorptionRate: 0.1,
                      clone: function(){ return new Paperspot(this.dyeAmounts, this.waterAmount); },
                  stringify: function(){ return JSON.stringify(this); },
                       copy: function(from){
                         this.waterAmount = from.waterAmount;
                         DYES.copyAmounts(from.dyeAmounts, this.dyeAmounts);
                       },
                 addDroplet: function(drop){
                    this.waterAmount = Math.max(this.waterAmount + drop.waterAmount, maxWaterCapacity);
                    for (var i = 0; i < this.dyeAmounts.length; i++) {
                      this.dyeAmounts[i] = this.dyeAmounts[i] + drop.dyeAmounts[i];
                    }
                    return this;
                  },
      };
    })();

    //------------

    var WaterSpot = function(waterAmount, dyeAmounts){
      this.waterAmount = (waterAmount)?         waterAmount : 0;
      this.dyeAmounts  =  (dyeAmounts)? dyeAmounts.slice(0) : DYES.newEmptyDyeAmounts();
    }

    WaterSpot.prototype = (function(){
      /* private members */

      /* public members */
      return {
             clone: function() { return new WaterSpot(this.waterAmount, this.dyeAmounts); },
        addDroplet: function(drop){
           this.waterAmount = this.waterAmount + drop.waterAmount;
           for (var i = 0; i < this.dyeAmounts.length; i++) {
             this.dyeAmounts[i] = this.dyeAmounts[i] + drop.dyeAmounts[i];
           }
           return this;
         },
          divideBy: function(n){
          this.waterAmount = this.waterAmount/n;
          for (var i = 0; i < this.dyeAmounts.length; i++) {
            this.dyeAmounts[i] = this.dyeAmounts[i] / n;
          }
          return this;
        },
         stringify: function(){ return JSON.stringify(this); },
              copy: function(from){
               this.waterAmount = from.waterAmount;
               DYES.copyAmounts(from.dyeAmounts, this.dyeAmounts);
              },
      };
    })();

    WaterSpot.createBigRedDrop = function() {
      const waterAmount = 1000.0;
      const dyeAmounts = DYES.newEmptyDyeAmounts();
      dyeAmounts[0] = 3000.0;
      const drop = new WaterSpot(waterAmount, dyeAmounts);
      return drop;
    }

    WaterSpot.createBigRandomDrop = function(volume=1000) {
      const waterAmount = volume;
      const dyeAmounts = DYES.newEmptyDyeAmounts();
      for (var i = 0; i < dyeAmounts.length; i++) {
        dyeAmounts[i] = volume*3*Math.random();
      }
      const drop = new WaterSpot(waterAmount, dyeAmounts);
      return drop;
    }

    //------------

    var CellSpot = function(paperSpot, waterSpot){
      this.paperSpot = (paperSpot)? paperSpot.clone() : new PaperSpot();
      this.waterSpot = (waterSpot)? waterSpot.clone() : new WaterSpot();
    }

    CellSpot.prototype = (function(){
      /* private members */

      /* public members */
      return {
              clone: function(){ return new CellSpot(this.paperSpot, this.waterSpot); },
         addDroplet: function(drop){ this.waterSpot.addDroplet(drop); },
          stringify: function(){ return JSON.stringify(this); },
               copy: function(from){
                 this.paperSpot.copy(from.paperSpot);
                 this.waterSpot.copy(from.waterSpot);
               },
      };
    })();

    //------------
    // accept a list of { x: , y: , droplet: }
    // loop over the list, reset each cell and add to the cell.next (because reset happens before process)

    CAWorld.prototype.addDroplets = function(spotsWithCoords) {
      for (spot of spotsWithCoords) {
        var cell = this.grid[spot.y][spot.x];
        if (! cell) {
          console.log(`DEBUG: CAWorld.prototype.addDroplets: spot.x=${spot.x}, spot.y=${spot.y}, this.height=${this.height}, this.width=${this.width}`);
        }
        // cell.reset();
        var cellSpot = cell.next;
        cellSpot.addDroplet(spot.droplet);
      }
    };

    //------------
    // accept a centre x,y of a drop of radius r, containing full WaterSpot of ink+water.
    // expand into a call to addDroplets

    CAWorld.prototype.addBigDrop = function(centreX, centreY, r, waterSpot) {
      const fromX = Math.floor( Math.max(centreX - r, 0));
      const   toX = Math.floor( Math.min(centreX + r, this.height-1));
      const fromY = Math.floor( Math.max(centreY - r, 0));
      const   toY = Math.floor( Math.min(centreY + r, this.width-1));

      const spotsWithCoords = [];

      // record any x,y that is within the radius of the centre
      for (var x=fromX; x<=toX; x++) {
        for (var y=fromY; y<=toY; y++) {
          const dx = x - centreX;
          const dy = y - centreY;

          if ((dx*dx + dy*dy) <= r*r) {
              spotsWithCoords.push({ x:x, y:y });
          }
        }
      }

      // assume waterSpot is divided equally between droplets
      const numDroplets = spotsWithCoords.length;
      const droplet = waterSpot.clone().divideBy(numDroplets);

      spotsWithCoords.forEach(swc => {
        swc.droplet = droplet.clone();
      });

      this.addDroplets(spotsWithCoords);
    };

    //------------
    // add a stepCount

    CAWorld.prototype.stepWithCount = function() {
      if( !this.stepCount ){ this.stepCount = 0; }
      this.stepCount = this.stepCount + 1;
      this.stepThroughAllProcesses();
    };

    CAWorld.prototype.resetGrid = function() {
  		var y, x;
  		for (y=0; y<this.height; y++) {
  			for (x=0; x<this.width; x++) {
  				this.grid[y][x].reset();
  			}
  		}
    }

    var neighborhood = [null, null, null, null, null, null, null, null];

    CAWorld.prototype.stepThroughProcess = function(processName) {
      this.resetGrid();

  		// bottom up, left to right processing
  		for (y=this.height-1; y>=0; y--) {
  			for (x=this.width-1; x>=0; x--) {
  				this.fillNeighbors(neighborhood, x, y);
  				var cell = this.grid[y][x];
  				cell[processName](neighborhood);

  				// perform any delays
  				for (var i=0; i<cell.delays.length; i++) {
  					cell.delays[i].steps--;
  					if (cell.delays[i].steps <= 0) {
  						// perform action and remove delay
  						cell.delays[i].action(cell);
  						cell.delays.splice(i, 1);
  						i--;
  					}
  				}
  			}
  		}
  	};

    CAWorld.prototype.stepThroughAllProcesses = function() {
      ['absorb', 'surfaceFlow'].forEach(name => {
        this.stepThroughProcess(name);
      });
    }


    //------------

    function createWorldOfBlottingPaperAndDyes(width, height) {
    	world = new CAWorld({
    		width: Math.floor(width),
    		height: Math.floor(height),
    	});

      world.directions = [world.LEFT, world.RIGHT, world.BOTTOM, world.TOP, world.TOPLEFT, world.TOPRIGHT, world.BOTTOMLEFT, world.BOTTOMRIGHT];

      // world.waterSpotFlowDownSlope = 0.5;

      world.EvaporationFromPaperRate   = 0.01;
      world.EvaporationFromSurfaceRate = 0.005;

      world.SpreadMinAmountToGoToDry = 0.01; // cell needs a min amount of surface water before spreading to a dry cell
      world.SpreadSlopeFactor = 0.1;          // if there's a slope, the downhill SpreadMinAmountToGoToDry is multiplied by this factor

      // tracking loss of substance (rather than moved between cells)
      world.waterSpotLost = new WaterSpot();
      world.waterEvaporationFromPaper   = new WaterSpot();
      world.waterEvaporationFromSurface = new WaterSpot();

    	world.registerCellType('paper', {
        getCellValue: function () {
          return this.value;
    		},
        getCellNextValue: function () {
          return this.next;
    		},
        sanityCheckValue: function() {
          function thisError(msg){
            throw new Error(`ERROR: (${this.x}, ${this.y}): ${msg}`);
          }
          if (thisValuePaperSpot.waterAmount < 0) { thisError(`thisValuePaperSpot.waterAmount < 0, ${thisValuePaperSpot.waterAmount}`); }
          if (thisValueWaterSpot.waterAmount < 0) { thisError(`thisValueWaterSpot.waterAmount < 0, ${thisValueWaterSpot.waterAmount}`); }
          for (var d = 0; d < DYES.length; d++) {
            if (thisValuePaperSpot.dyeAmounts[d] < 0) { thisError(`thisValuePaperSpot.dyeAmounts[${d}]<0, ${thisValuePaperSpot.dyeAmounts[d]}`); }
            if (thisValueWaterSpot.dyeAmounts[d] < 0) { thisError(`thisValueWaterSpot.dyeAmounts[${d}]<0, ${thisValueWaterSpot.dyeAmounts[d]}`); }
          }
        },
        absorb: function (neighbors) {
          // - some of the current surface water (plus the associated dyes) get absorbed
          //    - capacity of paper
          //    - Rf for the dyes? Dyes get concentrated in remaining/reducing surface water?
          //    - some dyes get absorbed 'deeper' into the paper?

          const thisNextWaterSpot  = this.next.waterSpot;
          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          if (thisValueWaterSpot.waterAmount > 0) {
            const remainingPaperWaterCapacity = thisValuePaperSpot.MaxWaterCapacity - thisValuePaperSpot.waterAmount;
            if (remainingPaperWaterCapacity > 0) {
              const waterAmountToBeAbsorbed = Math.min(thisValueWaterSpot.waterAmount, thisValuePaperSpot.WaterAbsorptionRate, remainingPaperWaterCapacity);
              const proportionWaterAmountToBeAbsorbed = (waterAmountToBeAbsorbed / thisValueWaterSpot.waterAmount);
              // transfer water: add to paper, remove from water
              thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount + waterAmountToBeAbsorbed;
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - waterAmountToBeAbsorbed;

              // transfer dyes: add to paper, remove from water
              for (var d = 0; d < DYES.length; d++) {
                const flowProportion = (proportionWaterAmountToBeAbsorbed == 1)? 1 : proportionWaterAmountToBeAbsorbed * DYES[d].Rf;
                const flowAmount = flowProportion * thisValueWaterSpot.dyeAmounts[d];
                thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] + flowAmount;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] - flowAmount;
              }
            }
          }

          return true;
        },
    		surfaceFlow: function (neighbors) {
          // - remaining surface water can flow (and splodge) from/to here, taking into account
          //    - when both cells are wet, flow towards midpoint of water amounts
          //    - when both cells are dry, nothing happens
          //    - when one cell is wet, the other dry, the wet one flows into the dry one if there is a min amount
          //    - if there is a slope, the min amount is adjusted accordingly (down for downhill, up for uphill)
          //    - dividing any amounts by 8
          //    - surface characteristics? could adjust the min height amount...
          //    - dyes flow in the same proportion as the water

          const thisNextWaterSpot  = this.next.waterSpot;
          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          function flowWithNhbr(direction, factorForMinHeight){
            // factorForMinHeight is factor when calculated from this cell.
            // - to multiply world.SpreadMinAmountToGoToDry
            // - Invert if from nhbr.

            const nhbr = neighbors[direction.index];

            // return as soon as we work out no flow will happen

            let nhbrValueWaterSpot;
            let nhbrValueWaterSpotWaterAmount = 0;
            if (nhbr) {
              nhbrValueWaterSpot            = nhbr.value.waterSpot;
              nhbrValueWaterSpotWaterAmount = nhbrValueWaterSpot.waterAmount;
            }
            // skip if both cells are dry, or here is dry and there is no nhbr
            if ((thisValueWaterSpot.waterAmount == 0) && ((!nhbr) || (nhbrValueWaterSpotWaterAmount == 0))) {
              return;
            }

            // return if either nhbr is empty, and the other is not wet enough
            if (thisValueWaterSpot.waterAmount == 0) {
              if (nhbrValueWaterSpotWaterAmount <= (world.SpreadMinAmountToGoToDry / factorForMinHeight)) {
                return;
              }
            } else if (nhbrValueWaterSpotWaterAmount == 0) {
              if (thisValueWaterSpot.waterAmount <= (world.SpreadMinAmountToGoToDry * factorForMinHeight) ) {
                return;
              }
            }

            // The amount to flow is half the difference,
            // divided by 8 because is only one of 8 different here<->nhbr interactions.
            // +ve means from here, -ve from nhbr.
            let waterAmountFlowing = (thisValueWaterSpot.waterAmount - nhbrValueWaterSpotWaterAmount) / (2 * 8) ;
            if (waterAmountFlowing == 0) {
              return;
            } else if (waterAmountFlowing > 0) { // from this cell to nhbr, so only record loss from this cell if there is no nhbr
              const proportionWaterAmountFlowing = waterAmountFlowing / thisValueWaterSpot.waterAmount;
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - waterAmountFlowing;
              if(!nhbr) { world.waterSpotLost.waterAmount = world.waterSpotLost.waterAmount + waterAmountFlowing; }

              // transfer dyes: in water
              for (var d = 0; d < DYES.length; d++) {
                const dyeAmountFlowing = thisValueWaterSpot.dyeAmounts[d] * proportionWaterAmountFlowing;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] - dyeAmountFlowing;
                if(!nhbr){ world.waterSpotLost.dyeAmounts[d] = world.waterSpotLost.dyeAmounts[d] + dyeAmountFlowing; }
              }
            } else { // waterAmountFlowing < 0, flowing from nhbr to this cell
              const waterAmountFlowingFromNhbr = - waterAmountFlowing;
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount + waterAmountFlowingFromNhbr;
              // transfer dyes: in water
              const proportionWaterAmountFlowing = waterAmountFlowingFromNhbr / nhbrValueWaterSpotWaterAmount;
              for (var d = 0; d < DYES.length; d++) {
                const dyeAmountFlowing = nhbrValueWaterSpot.dyeAmounts[d] * proportionWaterAmountFlowing;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] + dyeAmountFlowing;
              }
            }
          }

          // world.directions = [world.LEFT, world.RIGHT, world.BOTTOM, world.TOP, world.TOPLEFT, world.TOPRIGHT, world.BOTTOMLEFT, world.BOTTOMRIGHT];
          flowWithNhbr(world.LEFT       , 1                                       );
          flowWithNhbr(world.RIGHT      , 1                                       );
          flowWithNhbr(world.BOTTOM     ,    world.SpreadSlopeFactor              ); // BOTTOM is down
          flowWithNhbr(world.BOTTOMLEFT ,    world.SpreadSlopeFactor * Math.SQRT2 );
          flowWithNhbr(world.BOTTOMRIGHT,    world.SpreadSlopeFactor * Math.SQRT2 );
          flowWithNhbr(world.TOP        , 1/ world.SpreadSlopeFactor              );
          flowWithNhbr(world.TOPLEFT    , 1/(world.SpreadSlopeFactor * Math.SQRT2));
          flowWithNhbr(world.TOPRIGHT   , 1/(world.SpreadSlopeFactor * Math.SQRT2));

          return true;
        },
    		process: function (neighbors) {
          // do clever flow stuff here

          const DEBUGX1Y1 = false; // (this.x == 1 && this.y == 1); //false;
          const DEBUGX1Y0TOPNHBR = false; // (this.x == 1 && this.y == 0); //false;
          const DEBUGX1Y1TOPNHBR = false; // (this.x == 1 && this.y == 1); //false;
          const DEBUGX1Y1D0 = false; //true;

          if (DEBUGX1Y1) {
            console.log(`DEBUG: process: step ${world.stepCount}: (${this.x},${this.y}),
            this.next =${this.next.stringify()},
            this.value=${this.value.stringify()},
            this.prev =${this.prev.stringify()}`);
          }

          // The modelling works by examining the relative states of the .value versions,
          // and implementing the changes in the .next version of this cell.
          // There are two main types of changes:
          // - this cell is pushing out to neighbours (and depleting its amounts)
          // - this cell is receiving from neighbours (and increasing its amounts)
          // They both need to be implemented when examining 'this' cell,
          // so calculations are in effect done twice:
          // - working out what this cell is to push to its neighbours
          // - working out what the neighbours would push
          // The calculations, add/remove of assorted resources, accumulate in the .next value,
          // then the .next value is switched in to 'be' the current .value when 'reset' is invoked.

          this.next.copy(this.value);

          // - some of the current surface water (plus the associated dyes) get absorbed
          //    - capacity of paper
          //    - Rf for the dyes? Dyes get concentrated in remaining/reducing surface water?
          //    - some dyes get absorbed 'deeper' into the paper?

          const thisNextWaterSpot  = this.next.waterSpot;
          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          if (thisValueWaterSpot.waterAmount > 0) {
            const remainingPaperWaterCapacity = thisValuePaperSpot.MaxWaterCapacity - thisValuePaperSpot.waterAmount;
            if (remainingPaperWaterCapacity > 0) {
              const waterAmountToBeAbsorbed = Math.min(thisValueWaterSpot.waterAmount, thisValuePaperSpot.WaterAbsorptionRate, remainingPaperWaterCapacity);
              const proportionWaterAmountToBeAbsorbed = (waterAmountToBeAbsorbed / thisValueWaterSpot.waterAmount);
              // transfer water: add to paper, remove from water
              thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount + waterAmountToBeAbsorbed;
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - waterAmountToBeAbsorbed;

              if (DEBUGX1Y1D0 && this.x == 1 && this.y == 1) {
                console.log(`DEBUG:      (1,1): absorption: thisNextWaterSpot.waterAmount=${thisNextWaterSpot.waterAmount}`);
              }

              // transfer dyes: add to paper, remove from water
              for (var d = 0; d < DYES.length; d++) {
                const flowProportion = (proportionWaterAmountToBeAbsorbed == 1)? 1 : proportionWaterAmountToBeAbsorbed * DYES[d].Rf;
                const flowAmount = flowProportion * thisValueWaterSpot.dyeAmounts[d];
                thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] + flowAmount;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] - flowAmount;
                if (DEBUGX1Y1D0 && this.x == 1 && this.y == 1 && d==0) {
                  console.log(`DEBUG:                (1,1): absorption: dyeAmounts[0]: amount after absorption=${thisNextWaterSpot.dyeAmounts[d]}`);
                }
            }
            }
          }

          // at this stage, this cell has had absorption factored into its .next,
          // but we still interrogate nhbrs via their .value

          // - remaining surface water can flow (and splodge) from/to here, taking into account
          //    - when both cells are wet, flow towards midpoint of water amounts
          //    - when both cells are dry, nothing happens
          //    - when one cell is wet, the other dry, the wet one flows into the dry one if there is a min amount
          //    - if there is a slope, the min amount is adjusted accordingly (down for downhill, up for uphill)
          //    - dividing any amounts by 8
          //    - surface characteristics? could adjust the min height amount...

          const here = this; // for use inside flowWithNhbr

          function flowWithNhbr(direction, factorForMinHeight){
            // factorForMinHeight is factor when calculated from this cell.
            // - to multiply world.SpreadMinAmountToGoToDry
            // - Invert if from nhbr.

            const nhbr = neighbors[direction.index];

            // return as soon as we work out no flow will happen

            // skip if both cells are dry, or here is dry and there is no nhbr
            if ((thisNextWaterSpot.waterAmount == 0) && ((!nhbr) || (nhbr.value.waterSpot.waterAmount == 0))) {
              return;
            }

            // calc nhbr waterAmount, or 0 if no nhbr
            let nhbrWaterAmount = 0;
            let nhbrWaterAmountToBeAbsorbed = 0;
            let nhbrProportionWaterAmountToBeAbsorbed = 0;

            let nhbrValuePaperSpot;
            let nhbrValueWaterSpot;

            if (nhbr && (nhbr.value.waterSpot.waterAmount > 0)) {
              nhbrValuePaperSpot = nhbr.value.paperSpot;
              nhbrValueWaterSpot = nhbr.value.waterSpot;
              nhbrWaterAmount    = nhbrValueWaterSpot.waterAmount;

              const nhbrRemainingPaperWaterCapacity = nhbrValuePaperSpot.MaxWaterCapacity - nhbrValuePaperSpot.waterAmount;
              if (nhbrRemainingPaperWaterCapacity > 0) {
                nhbrWaterAmountToBeAbsorbed = Math.min(nhbrWaterAmount, nhbrValuePaperSpot.WaterAbsorptionRate, nhbrRemainingPaperWaterCapacity);
                nhbrProportionWaterAmountToBeAbsorbed = (nhbrWaterAmountToBeAbsorbed / nhbrWaterAmount);
              }
            }
            const nhbrWaterAmountAfterAbsorption = nhbrWaterAmount - nhbrWaterAmountToBeAbsorbed;
            if (DEBUGX1Y1D0 && nhbr && nhbr.x == 1 &&  nhbr.y == 1) {
              console.log(`DEBUG: from (${here.x},${here.y}): absorption: (1,1) as a nhbr:  waterAmount=${nhbrWaterAmountAfterAbsorption}`)
            }

            // return if either nhbr is empty, and the other is not wet enough
            if (thisNextWaterSpot.waterAmount == 0) {
              if (nhbrWaterAmountAfterAbsorption <= (world.SpreadMinAmountToGoToDry / factorForMinHeight)) {
                return;
              }
            } else if (nhbrWaterAmountAfterAbsorption == 0) {
              if (thisNextWaterSpot.waterAmount <= (world.SpreadMinAmountToGoToDry * factorForMinHeight) ) {
                return;
              }
            }

            // The amount to flow is half the difference.
            // +ve means from here, -ve from nhbr.
            // Divide by 8 because is only one of 8 different here<->nhbr interactions.
            let waterAmountFlowing = (thisNextWaterSpot.waterAmount - nhbrWaterAmountAfterAbsorption) / (2 * 8) ;

            if (waterAmountFlowing == 0) {
              return;
            } else if (waterAmountFlowing > 0) { // from this cell to nhbr, so only record loss from this cell if there is no nhbr
              const proportionWaterAmountFlowing = waterAmountFlowing / thisNextWaterSpot.waterAmount;
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - waterAmountFlowing;
              if(!nhbr) { world.waterSpotLost.waterAmount = world.waterSpotLost.waterAmount + waterAmountFlowing; }

              // transfer dyes: in water
              for (var d = 0; d < DYES.length; d++) {
                const dyeAmountFlowing = thisNextWaterSpot.dyeAmounts[d] * proportionWaterAmountFlowing;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] - dyeAmountFlowing;
                if(!nhbr){ world.waterSpotLost.dyeAmounts[d] = world.waterSpotLost.dyeAmounts[d] + dyeAmountFlowing; }
              }
            } else { // flowing from nhbr to this cell
              const waterAmountFlowingFromNhbr = - waterAmountFlowing;

              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount + waterAmountFlowingFromNhbr;
              // transfer dyes: in water
              const proportionWaterAmountFlowing = waterAmountFlowingFromNhbr / nhbrWaterAmountAfterAbsorption;
              for (var d = 0; d < DYES.length; d++) {
                const amountAbsorbed = nhbrValueWaterSpot.dyeAmounts[d] * DYES[d].Rf * nhbrProportionWaterAmountToBeAbsorbed;
                const amountNotAbsorbed = nhbrValueWaterSpot.dyeAmounts[d] - amountAbsorbed;
                const amountFlowing = amountNotAbsorbed * proportionWaterAmountFlowing;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] + amountFlowing;
                if (DEBUGX1Y1D0 && nhbr.x == 1 &&  nhbr.y == 1 && d==0) {
                  console.log(`DEBUG: from (${here.x},${here.y}): absorption: (1,1) as a nhbr: dyeAmounts[0] amountNotAbsorbed=${amountNotAbsorbed}`)
                }
              }
            }
          }

          // world.directions = [world.LEFT, world.RIGHT, world.BOTTOM, world.TOP, world.TOPLEFT, world.TOPRIGHT, world.BOTTOMLEFT, world.BOTTOMRIGHT];
          flowWithNhbr(world.LEFT       , 1                                       );
          flowWithNhbr(world.RIGHT      , 1                                       );
          flowWithNhbr(world.BOTTOM     ,    world.SpreadSlopeFactor              ); // BOTTOM is down
          flowWithNhbr(world.BOTTOMLEFT ,    world.SpreadSlopeFactor * Math.SQRT2 );
          flowWithNhbr(world.BOTTOMRIGHT,    world.SpreadSlopeFactor * Math.SQRT2 );
          flowWithNhbr(world.TOP        , 1/ world.SpreadSlopeFactor              );
          flowWithNhbr(world.TOPLEFT    , 1/(world.SpreadSlopeFactor * Math.SQRT2));
          flowWithNhbr(world.TOPRIGHT   , 1/(world.SpreadSlopeFactor * Math.SQRT2));

          // if (world.waterSpotFlowDownSlope > 0) {
          //   const fromNhbr = neighbors[world.TOP.index];
          //   const toNhbr   = neighbors[world.BOTTOM.index];
          //
          //   const waterAmountLost = thisNextWaterSpot.waterAmount * world.waterSpotFlowDownSlope;
          //   thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - waterAmountLost;
          //   // goes to BOTTOM, or off paper
          //   if (toNhbr == null) { world.waterSpotLost.waterAmount = world.waterSpotLost.waterAmount + waterAmountLost; }
          //   // transfer dyes: in water
          //   for (var d = 0; d < DYES.length; d++) {
          //     let dyeAmountLost = thisNextWaterSpot.dyeAmounts[d] * world.waterSpotFlowDownSlope;
          //     if (DEBUGX1Y0TOPNHBR) { console.log(`DEBUG: process: step ${world.stepCount}: (${this.x},${this.y}), d=${d}, dyeAmountLost=${dyeAmountLost}`); }
          //     thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] - dyeAmountLost;
          //     if (toNhbr == null) { world.waterSpotLost.dyeAmounts[d] = world.waterSpotLost.dyeAmounts[d] + dyeAmountLost; }
          //   }
          //
          //   if (fromNhbr !== null) {
          //     if (fromNhbr.value.waterSpot.waterAmount > 0) {
          //       const waterAmountToBeAbsorbedInNhbr = Math.min(fromNhbr.value.waterSpot.waterAmount,
          //                                                      fromNhbr.value.paperSpot.WaterAbsorptionRate,
          //                                                      (fromNhbr.value.paperSpot.MaxWaterCapacity - fromNhbr.value.paperSpot.waterAmount));
          //       const waterAmountRemainingOnNhbr = fromNhbr.value.waterSpot.waterAmount - waterAmountToBeAbsorbedInNhbr;
          //       const waterComingFromNhbr = waterAmountRemainingOnNhbr * world.waterSpotFlowDownSlope;
          //       if (waterComingFromNhbr > 0) {
          //         const proportionOfWaterComingFromNhbr = waterComingFromNhbr / waterAmountRemainingOnNhbr;
          //         thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount + waterComingFromNhbr;
          //         // transfer dyes: in water
          //         for (var d = 0; d < DYES.length; d++) {
          //           const proportionWaterAmountToBeAbsorbedInNhbr = (waterAmountToBeAbsorbedInNhbr / fromNhbr.value.waterSpot.waterAmount);
          //           const dyeAmountToBeAbsorbedInNhbr = proportionWaterAmountToBeAbsorbedInNhbr * fromNhbr.value.waterSpot.dyeAmounts[d] * DYES[d].Rf;
          //           const dyeAmountAvailableToComeOver = fromNhbr.value.waterSpot.dyeAmounts[d] - dyeAmountToBeAbsorbedInNhbr;
          //           const dyeAmountComingOver = dyeAmountAvailableToComeOver * proportionOfWaterComingFromNhbr;
          //           thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] + dyeAmountComingOver;
          //           if (DEBUGX1Y1TOPNHBR) { console.log(`DEBUG: process: step ${world.stepCount}: (${this.x},${this.y}), d=${d}, dyeAmountComingOver=${dyeAmountComingOver}`); }
          //         }
          //       }
          //     }
          //   }
          // }

          // -  water in paper will flow by capillary action, from high moisture to low
          //    - taking with it some dyes

          const remainingPaperWaterCapacity = thisValuePaperSpot.MaxWaterCapacity - thisValuePaperSpot.waterAmount;
          for (direction of world.directions) {
            let nhbr = neighbors[direction.index];
            if (nhbr !== null ) {
              let nhbrValuePaperSpot = nhbr.value.paperSpot;
              let deltaWaterAmount = (nhbrValuePaperSpot.waterAmount - thisValuePaperSpot.waterAmount);
              let deltaWaterAmountScaled = deltaWaterAmount / (2 * 8);
              if (remainingPaperWaterCapacity > 0 && deltaWaterAmountScaled > 0) {
                let waterFlowAmount = deltaWaterAmountScaled * (remainingPaperWaterCapacity / thisValuePaperSpot.MaxWaterCapacity);
                thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount + waterFlowAmount;
                for (var d = 0; d < DYES.length; d++) {
                  let flowAmount = waterFlowAmount * DYES[d].Rf * nhbrValuePaperSpot.dyeAmounts[d];
                  thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] + flowAmount;
                }
              } else if(deltaWaterAmountScaled < 0) {
                let nhbrRemainingPaperWaterCapacity = nhbrValuePaperSpot.MaxWaterCapacity - nhbrValuePaperSpot.waterAmount;
                if (nhbrRemainingPaperWaterCapacity > 0) {
                  let waterFlowAmount = (- deltaWaterAmountScaled) * (nhbrRemainingPaperWaterCapacity / nhbrValuePaperSpot.MaxWaterCapacity);
                  thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount - waterFlowAmount;
                  for (var d = 0; d < DYES.length; d++) {
                    let flowAmount = waterFlowAmount * DYES[d].Rf * thisValuePaperSpot.dyeAmounts[d];
                    thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] - flowAmount;
                  }
                }
              }
            }
          }

          // - ink will diffuse, in wet paper
          //    - assume is related to relative concentrations, flowing from high to low (where both sides are wet)

          if (thisValuePaperSpot.waterAmount > 0) {
            for (direction of world.directions) {
              let nhbr = neighbors[direction.index];
              if (nhbr !== null ) {
                let nhbrValuePaperSpot = nhbr.value.paperSpot;
                if (nhbrValuePaperSpot.waterAmount > 0) {
                  for (var d = 0; d < DYES.length; d++) {
                    let thisValueConcentration = thisValuePaperSpot.dyeAmounts[d] / thisValuePaperSpot.waterAmount;
                    let nhbrValueConcentration = nhbrValuePaperSpot.dyeAmounts[d] / nhbrValuePaperSpot.waterAmount;
                    let deltaConcentration = nhbrValueConcentration - thisValueConcentration;
                    if (deltaConcentration > 0) { // dye comes to here
                      let flowAmount = DYES[d].Rd * ((deltaConcentration / nhbrValueConcentration) / 2) * nhbrValuePaperSpot.dyeAmounts[d] / 8;
                      thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] + flowAmount;
                    } else if (deltaConcentration < 0) { // dye goes from here
                      let flowAmount = DYES[d].Rd * ((deltaConcentration / thisValueConcentration) / 2) * thisValuePaperSpot.dyeAmounts[d] / 8;
                      thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] + flowAmount;
                    }
                  }
                }
              }
            }
          }

          // - paper will dry out as water evaporates
          //    - assume will not evaporate from paper if water on surface
          //    - for simplicity, apply evaporation to computed Next, otherwise needs to be included in all other calculations
          //    - handle when there are dyes in surface water which fully evaporates

          // --> there's a leak in here somewhere...
          // if (thisNextWaterSpot.waterAmount > 0) {
          //   let evapAmount = Math.min(thisNextWaterSpot.waterAmount, world.EvaporationFromSurfaceRate);
          //   if (evapAmount > 0) {
          //     thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - evapAmount;
          //     world.waterEvaporationFromSurface.waterAmount = world.waterEvaporationFromSurface.waterAmount + evapAmount;
          //     if (thisNextWaterSpot.waterAmount == 0) {
          //       thisNextPaperSpot.addDroplet(thisNextWaterSpot);
          //       thisNextWaterSpot.dyeAmounts.fill(0);
          //     }
          //   }
          // }
          // else
          // if (thisNextPaperSpot.waterAmount > 0) {
          //   let evapAmount = Math.min(thisNextPaperSpot.waterAmount, world.EvaporationFromPaperRate);
          //   thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount - evapAmount;
          //   world.waterEvaporationFromPaper.waterAmount = world.waterEvaporationFromPaper.waterAmount + evapAmount;
          // }

          // - colours will change when wet/dry
          // - if dry, nothing will flow from this cell

          // sanity check on values

          function thisError(msg){
            throw new Error(`ERROR: (${this.x}, ${this.y}): ${msg}`);
          }
          if (thisValuePaperSpot.waterAmount < 0) { thisError(`thisValuePaperSpot.waterAmount < 0, ${thisValuePaperSpot.waterAmount}`); }
          if (thisValueWaterSpot.waterAmount < 0) { thisError(`thisValueWaterSpot.waterAmount < 0, ${thisValueWaterSpot.waterAmount}`); }
          for (var d = 0; d < DYES.length; d++) {
            if (thisValuePaperSpot.dyeAmounts[d] < 0) { thisError(`thisValuePaperSpot.dyeAmounts[${d}]<0, ${thisValuePaperSpot.dyeAmounts[d]}`); }
            if (thisValueWaterSpot.dyeAmounts[d] < 0) { thisError(`thisValueWaterSpot.dyeAmounts[${d}]<0, ${thisValueWaterSpot.dyeAmounts[d]}`); }
          }

          if (DEBUGX1Y1) {
            console.log(`DEBUG: process: step ${world.stepCount}: (${this.x},${this.y}), final next,
            this.next =${this.next.stringify()}`);
          }

    			return true;
    		},
    		reset: function () {
          let oldPrev = this.prev; // don't discard the old value
  				this.prev   = this.value;
  				this.value  = this.next;
          this.next   = oldPrev;
          this.next.copy(this.value); // so adds and deletes happen in the .next value
    			return true;
    		}
    	}, function (x,y) {
    		//init
        this.value = new CellSpot();
        this.prev  = new CellSpot();
    		this.next  = new CellSpot();
        this.x = x;
        this.y = y;
    	});

    	world.initialize([
    		{ name: 'paper', distribution: 100 }
    	]);

    	return world;
    }

    function createPaper(canvas, maxIterations=100){

        function convertWorldGridToGridOfDyeAmounts(world){
          var worldGrid = world.grid;
          var gridOfDyeAmounts = [];

          // imageData reads from top left to bottom right
          // world reads from bottom left to top right (I think)

          for (var x = 0; x < world.width; x++) {
            var col = [];
            gridOfDyeAmounts.push(col);
            for (var y = 0; y < world.height; y++) {
              col.push( worldGrid[y][x].getCellValue().paperSpot.dyeAmounts);
            }
          }

          return gridOfDyeAmounts;
        }

        function calcDyeAndWaterTotalsInWorld(world){
          const worldGrid = world.grid;
          const dyeAmountsInPaper    = DYES.newEmptyDyeAmounts();
          const dyeAmountsInWater    = DYES.newEmptyDyeAmounts();
          let waterAmountInPaper   = 0;
          let waterAmountOnSurface = 0;

          for (var x = 0; x < world.width; x++) {
            for (var y = 0; y < world.height; y++) {
              let cell = worldGrid[y][x].getCellNextValue();
              DYES.addAmounts(cell.paperSpot.dyeAmounts, dyeAmountsInPaper);
              DYES.addAmounts(cell.waterSpot.dyeAmounts, dyeAmountsInWater);
              waterAmountInPaper   = waterAmountInPaper   + cell.paperSpot.waterAmount;
              waterAmountOnSurface = waterAmountOnSurface + cell.waterSpot.waterAmount;
            }
          }

          const dyeAmountsTotal = DYES.newEmptyDyeAmounts();
          DYES.addAmounts(dyeAmountsInPaper, dyeAmountsTotal);
          DYES.addAmounts(dyeAmountsInWater, dyeAmountsTotal);
          DYES.addAmounts(world.waterSpotLost.dyeAmounts, dyeAmountsTotal);
          const dyeAmountTotal = dyeAmountsTotal.reduce( (prev, curr) => prev + curr );
          const waterAmountTotal = [
            waterAmountInPaper,
            waterAmountOnSurface,
            world.waterSpotLost.waterAmount,
            world.waterEvaporationFromPaper.waterAmount,
            world.waterEvaporationFromSurface.waterAmount
          ].reduce( (prev, curr) => prev + curr );

          return {
            waterAmountTotal    : waterAmountTotal,
            waterAmountInPaper  : waterAmountInPaper,
            waterAmountOnSurface: waterAmountOnSurface,
            waterAmountLost     : world.waterSpotLost.waterAmount,
            waterAmountEvaporationFromPaper   : world.waterEvaporationFromPaper.waterAmount,
            waterAmountEvaporationFromSurface : world.waterEvaporationFromSurface.waterAmount,
              dyeAmountTotal    :   dyeAmountTotal,
              dyeAmountsTotal   :   dyeAmountsTotal,
              dyeAmountsInPaper :   dyeAmountsInPaper,
              dyeAmountsInWater :   dyeAmountsInWater,
              dyeAmountsLost    : world.waterSpotLost.dyeAmounts,
                      stepCount : world.stepCount
          }
        }

        function calcDyeAndWaterTotalDelta(totalsList, relative=true){
          const first = (relative)? totalsList[totalsList.length - 2] : totalsList[0];
          const last  = totalsList[totalsList.length - 1];
          return {
              stepCountDelta : last.stepCount - first.stepCount + ((relative)? 0 : 1),
            waterAmountTotal : (last.waterAmountTotal - first.waterAmountTotal).toFixed(5),
              dyeAmountTotal : (last.dyeAmountTotal - first.dyeAmountTotal).toFixed(5),
          }
        }

        function createPaperAddDropsAndRun() {
          const context = canvas.getContext('2d');
          console.log(`canvas.width=${canvas.width}, canvas.height=${canvas.height}`);
          const imageData = context.getImageData(0,0,canvas.width,canvas.height);
          const world = createWorldOfBlottingPaperAndDyes(imageData.width, imageData.height);

          let numIterations=1;
          let batchSize = 10;
          const startOverallRunTimeMillis = Date.now();
          let   startBatchRunTimeMillis   = Date.now();
          const minAcceptableDelta = 0.1;

          let totals = calcDyeAndWaterTotalsInWorld(world);
          console.log(`iteration=0,`);
          // console.log(`     totals=${JSON.stringify(totals)}`);
          const totalsList = [];

          function calcAndDisplayTotals(relative=true){
            let fromTimeMillis = (relative)? startBatchRunTimeMillis : startBatchRunTimeMillis;
            let fromIndex      = (relative && totalsList.length > 2)? totalsList.length - 2   : 0;

            let nowMillis = Date.now();
            let frameRate = batchSize / ((nowMillis - fromTimeMillis) / 1000);
            let pixelRate = batchSize * world.width * world.height / ((nowMillis - startBatchRunTimeMillis) / 1000);
            console.log(`iteration=${numIterations}, frames/s=${frameRate.toFixed(2)}, pixels/s=${pixelRate.toFixed(0)}`);
            let totals = calcDyeAndWaterTotalsInWorld(world);
            totalsList.push(totals);
            if (totalsList.length > 1) {
              const totalsDelta = calcDyeAndWaterTotalDelta(totalsList, relative);
              if (Math.abs(totalsDelta.waterAmountTotal) > minAcceptableDelta || Math.abs(totalsDelta.dyeAmountTotal) > minAcceptableDelta) {
                console.log(`WARNING: delta error > ${minAcceptableDelta}
                  prev: ${JSON.stringify(totalsList[fromIndex])}
                  last: ${JSON.stringify(totalsList[totalsList.length - 1])}`);
                  console.log(`       totalsDelta=${JSON.stringify(totalsDelta)}`);
              }
              if (relative) {
                startBatchRunTimeMillis = nowMillis;
              }
            }
          }

          function iterateAndDisplayWorld(){
            // console.log(`world iteration=${numIterations} of ${maxIterations}`);
            world.stepWithCount();
            let gridOfDyeAmounts = convertWorldGridToGridOfDyeAmounts(world);
            DYES.writeGridOfDyeAmountsToImageData(gridOfDyeAmounts, imageData);
            context.putImageData(imageData, 0, 0);

            if ((numIterations % batchSize == 0) || numIterations==1 ) {
              calcAndDisplayTotals();
            }

            numIterations = numIterations + 1;
            if (numIterations < maxIterations) {
              window.requestAnimationFrame(iterateAndDisplayWorld);
            } else {
              const relative = true;
              calcAndDisplayTotals(!relative);
              console.log(`iterations ended.`);
              window.dispatchEvent( new Event('StopRecording') );
            }
          }

          // always have a drop on (1,1) for debugging
          world.addBigDrop(
            1,
            1,
            10+(Math.random()*20),
            WaterSpot.createBigRandomDrop()
          );

          const numDropsAcross = 5;
          const dropSpacing = world.width / (numDropsAcross+1);
          for (var i = 0; i < numDropsAcross; i++) {
            world.addBigDrop(
              (1+i) * dropSpacing,
              world.height / 4,
              2+(Math.random()*dropSpacing),
              WaterSpot.createBigRandomDrop(1000)
            );
          }

          iterateAndDisplayWorld();
        }

        return {
          run: createPaperAddDropsAndRun
        }
    }

    return {
      create: createPaper
    }
  })();
  </script>
</head>

<body>
  <h1>Chromatography</h1>

    <canvas class="blotting-paper" id="myCanvas" width="100" height="100"></canvas>

  <script>
  (function(){
    const codeVersion = '2-0'; // affects filename of recording
    const maxIterations = 200;

    const canvas = document.getElementById('myCanvas');
    const context = canvas.getContext('2d');

    {
      /* set up the recording of the canvas animations */
      const mimeType = 'video/webm'; // couldn't find a different format which worked, e.g. mp4.
      const options = {mimeType: mimeType};
      const recordedFile = `chromatography-experiment.${codeVersion}.webm`;
      function download(event) { // receives the recorded data, and writes to file using a url hack. Ick.
        const videoData = [ event.data ];
        const blob = new Blob(videoData, {
          type: mimeType
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        document.body.appendChild(a);
        a.style = 'display: none';
        a.href = url;
        a.download = recordedFile;
        a.click();
        window.URL.revokeObjectURL(url);
      }
      const frameRate = 15;
      const stream = canvas.captureStream(frameRate);
      const mediaRecorder = new MediaRecorder(stream, options);
      mediaRecorder.ondataavailable = download;
      mediaRecorder.start();
      // window.addEventListener('StopRecording', e => { mediaRecorder.stop(); })
    }

    {
      // paper starts clean and dry
      var paper = Chroma.create(canvas, maxIterations);
      window.setTimeout(paper.run, 100);
    }
  })();
  </script>
</body>
</html>
