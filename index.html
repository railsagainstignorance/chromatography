<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Chromatography</title>
  <style>
  .blotting-paper {
    border-width: 1px;
    border-color: lightgrey;
    border-style: solid;

    box-shadow: 10px 10px 5px #888888;

    background-color: white;
  }
  </style>
  <script src="assets/cellauto.min.js"></script>
  <script>
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  </script>
  <script>
  const Chroma = (function(){

    const DYES = [
      {
        name: 'red',
          Rf: 0.2,  // propensity to go with the flow
          Rd: 0.07, // propensity to 'bleed' if no flow
          RGBPattern: [1.0, 0, 0], // how to read it's value from/to RGB triple
      },
      {
        name: 'green',
          Rf: 0.3,
          Rd: 0.075,
          RGBPattern: [0, 1.0, 0],
      },
      {
        name: 'blue',
          Rf: 0.4,
          Rd: 0.06,
          RGBPattern: [0, 0, 1.0],
      },
    ];

    {
      // check internal consistency of Rf and Rd

      let numDirections = 8;

      for( let dye of DYES ){
        if ( (dye.Rf + (numDirections * dye.Rd)) > 1.0 ) {
          throw new Error(`ERROR: Rf + numDirections*Rd >1.0 for name=${dye.name}, Rf=${dye.Rf}, Rd=${dye.Rd}, numDirections=${numDirections}`);
        }
      }
    }

    DYES.RGBMaximum = 253;

    DYES.newEmptyDyeAmounts = function() {
      return new Array(this.length).fill(0);
    }

    DYES.copyAmounts = function(from, to){
      for (var i = 0; i < this.length; i++) {
        to[i] = from[i];
      }
    }

    DYES.combineDyesIntoRgbaPixel = function(dyeAmounts) {
      // return [R, G, B, A]
      // assume no dyes => full transparent

      // calc 0-1.0 range, then convert to 0-255 later
      var rgba01 = new Array(3).fill(0);

      for (var d = 0; d < this.length; d++) {
        for (var i = 0; i < 3; i++) {
          rgba01[i] = rgba01[i] + (dyeAmounts[d] * this[d].RGBPattern[i]);
        }
      }

      var maxRGB01 = Math.max.apply(null, rgba01);
      if (maxRGB01 > 1.0) {
        rgba01 = rgba01.map(c => {return c/maxRGB01});
        maxRGB01 = 1.0;
      }
      rgba01.push(maxRGB01);

      var rgba = rgba01.map(c => {return (c>1.0)? 255 : Math.floor(c * 255);});
      return rgba;
    }

    DYES.writeGridOfDyeAmountsToImageData = function(grid, imageData){
      if ((imageData.width !== grid.length) || (imageData.height !== grid[0].length)) {
        throw new Error(`Error: mismatch found between size of grid and imageData`);
      }
      const data = imageData.data;
      for (var x=0; x<imageData.width; x++) {
        for (var y=0; y<imageData.height; y++) {
          var dyeAmounts = grid[x][y];
          var rgba = this.combineDyesIntoRgbaPixel(dyeAmounts);
          var dataCellIndex = 4 * (x + (y * imageData.width));
          for (var i = 0; i < 4; i++) {
            data[dataCellIndex+i] = rgba[i];
          }
        }
      }
      return imageData;
    }

    //------------

    var PaperSpot = function(dyeAmounts, waterAmount){
      this.dyeAmounts  =  (dyeAmounts)? dyeAmounts.slice(0) : DYES.newEmptyDyeAmounts();
      this.waterAmount = (waterAmount)?        waterAmounts : 0;
    }

    PaperSpot.prototype = (function () {
      /* private members */

      /* public members */
      return {
           MaxWaterCapacity: 1,
        WaterAbsorptionRate: 0.1,
                      clone: function(){ return new Paperspot(this.dyeAmounts, this.waterAmount); },
                  stringify: function(){ return JSON.stringify(this); },
                       copy: function(from){
                         this.waterAmount = from.waterAmount;
                         DYES.copyAmounts(from.dyeAmounts, this.dyeAmounts);
                       },
      };
    })();

    //------------

    var WaterSpot = function(waterAmount, dyeAmounts){
      this.waterAmount = (waterAmount)?         waterAmount : 0;
      this.dyeAmounts  =  (dyeAmounts)? dyeAmounts.slice(0) : DYES.newEmptyDyeAmounts();
    }

    WaterSpot.prototype = (function(){
      /* private members */

      /* public members */
      return {
             clone: function() { return new WaterSpot(this.waterAmount, this.dyeAmounts); },
        addDroplet: function(drop){
           this.waterAmount = this.waterAmount + drop.waterAmount;
           for (var i = 0; i < this.dyeAmounts.length; i++) {
             this.dyeAmounts[i] = this.dyeAmounts[i] + drop.dyeAmounts[i];
           }
           return this;
         },
          divideBy: function(n){
          this.waterAmount = this.waterAmount/n;
          for (var i = 0; i < this.dyeAmounts.length; i++) {
            this.dyeAmounts[i] = this.dyeAmounts[i] / n;
          }
          return this;
        },
         stringify: function(){ return JSON.stringify(this); },
              copy: function(from){
               this.waterAmount = from.waterAmount;
               DYES.copyAmounts(from.dyeAmounts, this.dyeAmounts);
              },
      };
    })();

    WaterSpot.createBigRedDrop = function() {
      const waterAmount = 1000.0;
      const dyeAmounts = DYES.newEmptyDyeAmounts();
      dyeAmounts[0] = 3000.0;
      const drop = new WaterSpot(waterAmount, dyeAmounts);
      return drop;
    }

    WaterSpot.createBigRandomDrop = function() {
      const waterAmount = 1000.0;
      const dyeAmounts = DYES.newEmptyDyeAmounts();
      for (var i = 0; i < dyeAmounts.length; i++) {
        dyeAmounts[i] = 3000.0*Math.random();
      }
      const drop = new WaterSpot(waterAmount, dyeAmounts);
      return drop;
    }

    //------------

    var CellSpot = function(paperSpot, waterSpot){
      this.paperSpot = (paperSpot)? paperSpot.clone() : new PaperSpot();
      this.waterSpot = (waterSpot)? waterSpot.clone() : new WaterSpot();
    }

    CellSpot.prototype = (function(){
      /* private members */

      /* public members */
      return {
              clone: function(){ return new CellSpot(this.paperSpot, this.waterSpot); },
         addDroplet: function(drop){ this.waterSpot.addDroplet(drop); },
          stringify: function(){ return JSON.stringify(this); },
               copy: function(from){
                 this.paperSpot.copy(from.paperSpot);
                 this.waterSpot.copy(from.waterSpot);
               },
      };
    })();

    //------------
    // accept a list of { x: , y: , droplet: }
    // loop over the list, reset each cell and add to the cell.value

    CAWorld.prototype.addDroplets = function(spotsWithCoords) {
      for (spot of spotsWithCoords) {
        var cell = this.grid[spot.y][spot.x];
        if (! cell) {
          console.log(`DEBUG: CAWorld.prototype.addDroplets: spot.x=${spot.x}, spot.y=${spot.y}, this.height=${this.height}, this.width=${this.width}`);
        }
        // cell.reset();
        var cellSpot = cell.value;
        cellSpot.addDroplet(spot.droplet);
      }
    };

    //------------
    // accept a centre x,y of a drop of radius r, containing full WaterSpot of ink+water.
    // expand into a call to addDroplets

    CAWorld.prototype.addBigDrop = function(centreX, centreY, r, waterSpot) {
      const fromX = Math.floor( Math.max(centreX - r, 0));
      const   toX = Math.floor( Math.min(centreX + r, this.height-1));
      const fromY = Math.floor( Math.max(centreY - r, 0));
      const   toY = Math.floor( Math.min(centreY + r, this.width-1));

      const spotsWithCoords = [];

      // record any x,y that is within the radius of the centre
      for (var x=fromX; x<=toX; x++) {
        for (var y=fromY; y<=toY; y++) {
          const dx = x - centreX;
          const dy = y - centreY;

          if ((dx*dx + dy*dy) <= r*r) {
              spotsWithCoords.push({ x:x, y:y });
          }
        }
      }

      // assume waterSpot is divided equally between droplets
      const numDroplets = spotsWithCoords.length;
      const droplet = waterSpot.clone().divideBy(numDroplets);

      spotsWithCoords.forEach(swc => {
        swc.droplet = droplet.clone();
      });

      this.addDroplets(spotsWithCoords);
    };

    //------------
    // add a stepCount
    // loop over the list, reset each cell and add to the cell.value

    CAWorld.prototype.stepWithCount = function() {
      if( !this.stepCount ){ this.stepCount = 0; }
      this.stepCount = this.stepCount + 1;
      this.step();
    };

    //------------

    function createWorldOfBlottingPaperAndDyes(width, height) {
    	world = new CAWorld({
    		width: Math.floor(width),
    		height: Math.floor(height),
    	});

      world.flowRate        = 1.0;
      world.bleedDirections = [world.LEFT, world.RIGHT, world.BOTTOM, world.TOP, world.TOPLEFT, world.TOPRIGHT, world.BOTTOMLEFT, world.BOTTOMRIGHT];
      world.numDyes         = DYES.length;

    	world.registerCellType('paper', {
    		getCellValue: function () {
          return this.value;
    		},
    		process: function (neighbors) {
          // do clever flow stuff here

          // // starting with ...
          // // any water dye goes straight into the paper
          //
          // for (var i = 0; i < world.numDyes; i++) {
          //   this.next.paperSpot.dyeAmounts[i] = this.value.paperSpot.dyeAmounts[i] + this.next.waterSpot.dyeAmounts[i];
          //   this.next.waterSpot.dyeAmounts[i] = 0;
          // }

          // - some of the current surface water (plus the associated dyes) get absorbed
          //    - capacity of paper
          //    - Rf for the dyes? Dyes get concentrated in remaining/reducing surface water?
          //    - some dyes get absorbed 'deeper' into the paper?

          if (this.x == 0 && this.y == 0) {
            console.log(`DEBUG: process: step ${world.stepCount}: (${this.x},${this.y}),
            this.value=${this.value.stringify()},
            this.next=${this.next.stringify()}`);
          }

          this.next.copy(this.value);
          if (this.value.paperSpot.waterAmount < this.value.paperSpot.MaxWaterCapacity) {
            if (this.value.waterSpot.waterAmount > 0) {
              const waterAmountToBeAbsorbed = Math.min(this.value.waterSpot.waterAmount, this.value.waterSpot.WaterAbsorptionRate);
              const proportionWaterAmountToBeAbsorbed = (this.value.waterSpot.waterAmount == 0)? 1.0 : (waterAmountToBeAbsorbed / this.value.waterSpot.waterAmount);
              // transfer water: add to paper, remove from water
              this.next.paperSpot.waterAmount = this.next.paperSpot.waterAmount + waterAmountToBeAbsorbed;
              this.next.waterSpot.waterAmount = this.next.waterSpot.waterAmount - waterAmountToBeAbsorbed;
              // transfer dyes: add to paper, remove from water
              for (var d = 0; d < DYES.length; d++) {
                const  flowAmount = proportionWaterAmountToBeAbsorbed * this.value.waterSpot.dyeAmounts[d] * DYES[d].Rf;
                this.next.paperSpot.dyeAmounts[d] = this.next.paperSpot.dyeAmounts[d] + flowAmount;
                this.next.waterSpot.dyeAmounts[d] = this.next.waterSpot.dyeAmounts[d] + flowAmount;
              }
            }
          }

          // - remaining surface water can flow from/to here, taking into account
          //    - from high to low amounts
          //    - a slope
          //    - surface characteristics
          // -  water in paper will, flow by capillary action, from high concentration to low
          //    - taking with it some dyes
          // - ink will diffuse, in wet paper
          // - paper will dry out as water evaporates
          // - colours will change when wet/dry
          // - if dry, nothing will flow from this cell


          // for (var d = 0; d < DYES.length; d++) {
          //   const  flowAmount = this.value[d] * DYES[d].Rf * world.flowRate;
          //   const bleedAmount = this.value[d] * DYES[d].Rd;
          //
          //   this.next[d] = this.value[d];
          //
          //   // some of this cell's dyes will flow to BOTTOM
          //   if (neighbors[world.BOTTOM.index] !== null) {
          //     this.next[d] = this.next[d] - flowAmount;
          //   }
          //   // this cell will receive a flow from TOP
          //   if (neighbors[world.TOP.index] !== null) {
          //     this.next[d] = this.next[d] + (neighbors[world.TOP.index].value[d] * DYES[d].Rf);
          //   }
          //
          //   // this cell will receive a bleed from, and bleed to, each of the directions
          //   for( let direction of world.bleedDirections ){
          //     if (neighbors[direction.index] !== null) {
          //       this.next[d] = this.next[d] + (neighbors[direction.index].value[d] * DYES[d].Rd);
          //       this.next[d] = this.next[d] - bleedAmount;
          //     }
          //   }
          // }

          // // experiment with simple fading
          // for (var d = 0; d < DYES.length; d++) {
          //   this.next[d] = this.value[d] * (1 - DYES[d].Rf);
          // }

    			return true;
    		},
    		reset: function () {
          let oldPrev = this.prev; // don't discard the old value
  				this.prev   = this.value;
  				this.value  = this.next;
          this.next   = oldPrev;   // assuming the old value gets fully overwritten
    			return true;
    		}
    	}, function (x,y) {
    		//init
        this.value = new CellSpot();
        this.prev  = new CellSpot();
    		this.next  = new CellSpot();
        this.x = x;
        this.y = y;
    	});

    	world.initialize([
    		{ name: 'paper', distribution: 100 }
    	]);

    	return world;
    }

    function convertWorldGridToGridOfDyeAmounts(worldGrid){
      var gridOfDyeAmounts = [];

      for (var x = 0; x < worldGrid.length; x++) {
        var col = [];
        gridOfDyeAmounts.push(col);
        for (var y = 0; y < worldGrid[0].length; y++) {
          col.push( worldGrid[x][y].getCellValue().paperSpot.dyeAmounts);
        }
      }

      return gridOfDyeAmounts;
    }

    function createPaper(canvas, maxIterations=100){
        function addSolvent() {
          const context = canvas.getContext('2d');
          console.log(`canvas.width=${canvas.width}, canvas.height=${canvas.height}`);
          const imageData = context.getImageData(0,0,canvas.width,canvas.height);
          const world = createWorldOfBlottingPaperAndDyes(imageData.width, imageData.height);

          let numIterations=1;
          let batchSize = 5;
          const startOverallRunTimeMillis = Date.now();
          let   startBatchRunTimeMillis   = Date.now();

          function iterateAndDisplayWorld(){
            // console.log(`world iteration=${numIterations} of ${maxIterations}`);
            world.stepWithCount();
            let gridOfDyeAmounts = convertWorldGridToGridOfDyeAmounts(world.grid);
            DYES.writeGridOfDyeAmountsToImageData(gridOfDyeAmounts, imageData);
            context.putImageData(imageData, 0, 0);

            world.addBigDrop(
              // world.width  * Math.random(),
              // world.height * Math.random(),
              0,
              0,
              10+(Math.random()*20),
              WaterSpot.createBigRandomDrop()
            );

            if (numIterations % batchSize == 0) {
              let nowMillis = Date.now();
              let rate = batchSize / ((nowMillis - startBatchRunTimeMillis) / 1000);
              console.log(`iteration=${numIterations}, frames/s=${rate.toFixed(2)}`);
              startBatchRunTimeMillis = nowMillis;
            }

            numIterations = numIterations + 1;
            if (numIterations < maxIterations) {
              window.requestAnimationFrame(iterateAndDisplayWorld);
            } else {
              let nowMillis = Date.now();
              let rate = (numIterations - 1) / ((nowMillis - startOverallRunTimeMillis) / 1000);
              console.log(`ending on world iteration=${numIterations} of ${maxIterations}, frames/s=${rate.toFixed(2)}`);
              window.dispatchEvent( new Event('StopRecording') );
            }
          }

          iterateAndDisplayWorld();
        }

        return {
          run: addSolvent
        }
    }

    return {
      create: createPaper
    }
  })();
  </script>
</head>

<body>
  <h1>Chromatography</h1>

    <canvas class="blotting-paper" id="myCanvas" width="400" height="400"></canvas>

  <script>
  (function(){
    const codeVersion = '2-0'; // affects filename of recording
    const maxIterations = 10;

    const canvas = document.getElementById('myCanvas');
    const context = canvas.getContext('2d');

    {
      /* set up the recording of the canvas animations */
      const mimeType = 'video/webm'; // couldn't find a different format which worked, e.g. mp4.
      const options = {mimeType: mimeType};
      const recordedFile = `chromatography-experiment.${codeVersion}.webm`;
      function download(event) { // receives the recorded data, and writes to file using a url hack. Ick.
        const videoData = [ event.data ];
        const blob = new Blob(videoData, {
          type: mimeType
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        document.body.appendChild(a);
        a.style = 'display: none';
        a.href = url;
        a.download = recordedFile;
        a.click();
        window.URL.revokeObjectURL(url);
      }
      const frameRate = 15;
      const stream = canvas.captureStream(frameRate);
      const mediaRecorder = new MediaRecorder(stream, options);
      mediaRecorder.ondataavailable = download;
      mediaRecorder.start();
      // window.addEventListener('StopRecording', e => { mediaRecorder.stop(); })
    }

    {
      // paper starts clean and dry
      var paper = Chroma.create(canvas, maxIterations);
      window.setTimeout(paper.run, 100);
    }
  })();
  </script>
</body>
</html>
