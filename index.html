<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Chromatography</title>
  <style>
  .blotting-paper {
    border-width: 1px;
    border-color: lightgrey;
    border-style: solid;

    box-shadow: 10px 10px 5px #888888;

    background-color: white;
  }
  #myCanvas { // make them canvas pixels bigger. Assuming the canvas is 100x100, the pixels become 4x4
    width: 400px;
    height: 400px;
  }
  </style>
  <script src="assets/cellauto.min.js"></script>
  <script>
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  </script>
  <script>
  const Chroma = (function(){

    const DYES = [
      {
        name: 'red',
          Rf: 0.2,  // propensity to go with the flow
          Rd: 0.07, // propensity to 'bleed' if no flow
          RGBPattern: [1.0, 0, 0], // how to read it's value from/to RGB triple
      },
      {
        name: 'green',
          Rf: 0.3,
          Rd: 0.075,
          RGBPattern: [0, 1.0, 0],
      },
      {
        name: 'blue',
          Rf: 0.4,
          Rd: 0.06,
          RGBPattern: [0, 0, 1.0],
      },
    ];

    {
      // check internal consistency of Rf and Rd

      let numDirections = 8;

      for( let dye of DYES ){
        if ( (dye.Rf + (numDirections * dye.Rd)) > 1.0 ) {
          throw new Error(`ERROR: Rf + numDirections*Rd >1.0 for name=${dye.name}, Rf=${dye.Rf}, Rd=${dye.Rd}, numDirections=${numDirections}`);
        }
      }
    }

    DYES.RGBMaximum = 253;

    DYES.newEmptyDyeAmounts = function() {
      return new Array(this.length).fill(0);
    }

    DYES.copyAmounts = function(from, to){
      for (var i = 0; i < this.length; i++) {
        to[i] = from[i];
      }
    }

    DYES.addAmounts = function(from, to){
      for (var i = 0; i < this.length; i++) {
        to[i] = to[i] + from[i];
      }
    }

    DYES.subtractAmounts = function(from, to){
      for (var i = 0; i < this.length; i++) {
        to[i] = to[i] - from[i];
      }
    }

    DYES.combineDyesIntoRgbaPixel = function(dyeAmounts) {
      // return [R, G, B, A]
      // assume no dyes => full white

      // calc 0-1.0 range, then convert to 0-255 later
      var rgba01 = new Array(3).fill(0);

      for (var d = 0; d < this.length; d++) {
        for (var i = 0; i < 3; i++) {
          rgba01[i] = rgba01[i] + (dyeAmounts[d] * this[d].RGBPattern[i]);
        }
      }

      var maxRGB01 = Math.max.apply(null, rgba01);
      if (maxRGB01 > 1.0) {
        rgba01 = rgba01.map(c => {return c/maxRGB01});
        maxRGB01 = 1.0;
      }
      rgba01.push(maxRGB01);
      if (maxRGB01 == 0) {
        rgba01.fill(1.0);
      }

      var rgba = rgba01.map(c => {return (c>1.0)? 255 : Math.floor(c * 255);});
      return rgba;
    }

    DYES.writeGridOfDyeAmountsToImageData = function(grid, imageData){
      if ((imageData.width !== grid.length) || (imageData.height !== grid[0].length)) {
        throw new Error(`Error: mismatch found between size of grid and imageData`);
      }
      const data = imageData.data;
      for (var x=0; x<imageData.width; x++) {
        for (var y=0; y<imageData.height; y++) {
          var dyeAmounts = grid[x][y];
          var rgba = this.combineDyesIntoRgbaPixel(dyeAmounts);
          var dataCellIndex = 4 * (x + (y * imageData.width));
          for (var i = 0; i < 4; i++) {
            data[dataCellIndex+i] = rgba[i];
          }
        }
      }
      return imageData;
    }

    //------------

    var PaperSpot = function(dyeAmounts, waterAmount){
      this.dyeAmounts  =  (dyeAmounts)? dyeAmounts.slice(0) : DYES.newEmptyDyeAmounts();
      this.waterAmount = (waterAmount)?        waterAmounts : 0;
    }

    PaperSpot.prototype = (function () {
      /* private members */
      let maxWaterCapacity = 1;
      /* public members */
      return {
           MaxWaterCapacity: maxWaterCapacity,
        WaterAbsorptionRate: 0.1,
                      clone: function(){ return new Paperspot(this.dyeAmounts, this.waterAmount); },
                  stringify: function(){ return JSON.stringify(this); },
                       copy: function(from){
                         this.waterAmount = from.waterAmount;
                         DYES.copyAmounts(from.dyeAmounts, this.dyeAmounts);
                       },
                 addDroplet: function(drop){
                    this.waterAmount = Math.min(this.waterAmount + drop.waterAmount, maxWaterCapacity);
                    for (var i = 0; i < this.dyeAmounts.length; i++) {
                      this.dyeAmounts[i] = this.dyeAmounts[i] + drop.dyeAmounts[i];
                    }
                    return this;
                  },
      };
    })();

    //------------

    var WaterSpot = function(waterAmount, dyeAmounts){
      this.waterAmount = (waterAmount)?         waterAmount : 0;
      this.dyeAmounts  =  (dyeAmounts)? dyeAmounts.slice(0) : DYES.newEmptyDyeAmounts();
    }

    WaterSpot.prototype = (function(){
      /* private members */

      /* public members */
      return {
             clone: function() { return new WaterSpot(this.waterAmount, this.dyeAmounts); },
        addDroplet: function(drop){
           this.waterAmount = this.waterAmount + drop.waterAmount;
           for (var i = 0; i < this.dyeAmounts.length; i++) {
             this.dyeAmounts[i] = this.dyeAmounts[i] + drop.dyeAmounts[i];
           }
           return this;
         },
          divideBy: function(n){
          this.waterAmount = this.waterAmount/n;
          for (var i = 0; i < this.dyeAmounts.length; i++) {
            this.dyeAmounts[i] = this.dyeAmounts[i] / n;
          }
          return this;
        },
         stringify: function(){ return JSON.stringify(this); },
              copy: function(from){
               this.waterAmount = from.waterAmount;
               DYES.copyAmounts(from.dyeAmounts, this.dyeAmounts);
              },
      };
    })();

    WaterSpot.createBigRedDrop = function() {
      const waterAmount = 1000.0;
      const dyeAmounts = DYES.newEmptyDyeAmounts();
      dyeAmounts[0] = 3000.0;
      const drop = new WaterSpot(waterAmount, dyeAmounts);
      return drop;
    }

    WaterSpot.createBigRandomDrop = function(volume=1000) {
      const waterAmount = volume;
      const dyeAmounts = DYES.newEmptyDyeAmounts();
      for (var i = 0; i < dyeAmounts.length; i++) {
        dyeAmounts[i] = volume*3*Math.random();
      }
      const drop = new WaterSpot(waterAmount, dyeAmounts);
      return drop;
    }

    //------------

    var CellSpot = function(paperSpot, waterSpot){
      this.paperSpot = (paperSpot)? paperSpot.clone() : new PaperSpot();
      this.waterSpot = (waterSpot)? waterSpot.clone() : new WaterSpot();
    }

    CellSpot.prototype = (function(){
      /* private members */

      /* public members */
      return {
              clone: function(){ return new CellSpot(this.paperSpot, this.waterSpot); },
         addDroplet: function(drop){ this.waterSpot.addDroplet(drop); },
          stringify: function(){ return JSON.stringify(this); },
               copy: function(from){
                 this.paperSpot.copy(from.paperSpot);
                 this.waterSpot.copy(from.waterSpot);
               },
      };
    })();

    //------------
    // accept a list of { x: , y: , droplet: }
    // loop over the list, reset each cell and add to the cell.next (because reset happens before process)

    CAWorld.prototype.addDroplets = function(spotsWithCoords) {
      for (spot of spotsWithCoords) {
        var cell = this.grid[spot.y][spot.x];
        if (! cell) {
          console.log(`DEBUG: CAWorld.prototype.addDroplets: spot.x=${spot.x}, spot.y=${spot.y}, this.height=${this.height}, this.width=${this.width}`);
        }
        // cell.reset();
        var cellSpot = cell.next;
        cellSpot.addDroplet(spot.droplet);
        this.waterDropletsAddedToSurface.addDroplet(spot.droplet);
      }
    };

    //------------
    // accept a centre x,y of a drop of radius r, containing full WaterSpot of ink+water.
    // expand into a call to addDroplets

    CAWorld.prototype.addBigDrop = function(centreX, centreY, r, waterSpot) {
      const fromX = Math.floor( Math.max(centreX - r, 0));
      const   toX = Math.floor( Math.min(centreX + r, this.height-1));
      const fromY = Math.floor( Math.max(centreY - r, 0));
      const   toY = Math.floor( Math.min(centreY + r, this.width-1));

      const spotsWithCoords = [];

      // record any x,y that is within the radius of the centre
      for (var x=fromX; x<=toX; x++) {
        for (var y=fromY; y<=toY; y++) {
          const dx = x - centreX;
          const dy = y - centreY;

          if ((dx*dx + dy*dy) <= r*r) {
              spotsWithCoords.push({ x:x, y:y });
          }
        }
      }

      // assume waterSpot is divided equally between droplets
      const numDroplets = spotsWithCoords.length;
      const droplet = waterSpot.clone().divideBy(numDroplets);

      spotsWithCoords.forEach(swc => {
        swc.droplet = droplet.clone();
      });

      this.addDroplets(spotsWithCoords);
    };

    //------------
    // add a stepCount

    CAWorld.prototype.stepWithCount = function() {
      if( !this.stepCount ){ this.stepCount = 0; }
      this.stepCount = this.stepCount + 1;
      this.stepThroughAllProcesses();
    };

    CAWorld.prototype.resetGrid = function() {
  		var y, x;
  		for (y=0; y<this.height; y++) {
  			for (x=0; x<this.width; x++) {
  				this.grid[y][x].reset();
  			}
  		}
    }

    var neighborhood = [null, null, null, null, null, null, null, null];

    CAWorld.prototype.stepThroughProcess = function(processName) {
      this.resetGrid();

  		// bottom up, left to right processing
  		for (y=this.height-1; y>=0; y--) {
  			for (x=this.width-1; x>=0; x--) {
  				this.fillNeighbors(neighborhood, x, y);
  				var cell = this.grid[y][x];
  				cell[processName](neighborhood);

  				// perform any delays
  				for (var i=0; i<cell.delays.length; i++) {
  					cell.delays[i].steps--;
  					if (cell.delays[i].steps <= 0) {
  						// perform action and remove delay
  						cell.delays[i].action(cell);
  						cell.delays.splice(i, 1);
  						i--;
  					}
  				}
  			}
  		}
  	};

    CAWorld.prototype.stepThroughAllProcesses = function() {
      ['absorption', 'surfaceFlow', 'capillaryFlow', 'diffusion', 'evaporation', 'sanityCheckValue'].forEach(name => {
        this.stepThroughProcess(name);
      });
    }

    //------------

    function createWorldOfBlottingPaperAndDyes(width, height, config={ EvaporationFromSurfaceRate: -1}) {
    	world = new CAWorld({
    		width: Math.floor(width),
    		height: Math.floor(height),
    	});

      world.directions = [world.LEFT, world.RIGHT, world.BOTTOM, world.TOP, world.TOPLEFT, world.TOPRIGHT, world.BOTTOMLEFT, world.BOTTOMRIGHT];
      // tracking loss/gain of substance (rather than moved between cells)
      world.waterSpotLost = new WaterSpot();
      world.waterEvaporationFromPaper   = new WaterSpot();
      world.waterEvaporationFromSurface = new WaterSpot();
      world.waterDropletsAddedToSurface = new WaterSpot(); // to be subtracted from the final totals

      const ARBITRARY_MAX = 1000;
      world.defaultConfig = {
        EvaporationFromPaperRate : {
                value : 0.01,
                range : [0, ARBITRARY_MAX],
          description : 'max amount of absorbed water which will evaporate from the paper',
        },
        EvaporationFromSurfaceRate : {
                value : 0.005,
                range : [0, ARBITRARY_MAX],
          description : 'max amount of surface water which will evaoprate from the paper',
        },
        SpreadMinAmountToGoToDry : {
                value : 0.01,
                range : [0, ARBITRARY_MAX],
          description : "cell needs this min amount of surface water before spreading to a dry cell"
        },
        SpreadSlopeFactor : {
                value : 0.1,
                range : [0, ARBITRARY_MAX],
          description : "if there's a slope, the downhill SpreadMinAmountToGoToDry is multiplied by this factor"
        },
        PaperAbsorptionFactor : {
                value : 0.5,
                range : [0, 1],
          description : 'modify the water absorption rate across the whole paper'
        }
      };

      // loop over keys of defaultConfig, looking for overides in config
      Object.keys(world.defaultConfig).forEach( key => {
        const details = world.defaultConfig[key];
        if (details.hasOwnProperty('value')) {
          world[key] = details.value;

          if (config != undefined) {
            const newValue = config[key];
            if (newValue != undefined ) {
              if (details.range) {
                if (details.range[0] <= newValue && newValue <= details.range[1]) {
                  world[key] = newValue;
                  details.override = newValue;
                } else {
                  console.log(`WARNING: world: config: override value specified for ${key}, ${newValue}, falls outside of permitted range, ${details.range}`)
                }
              }
            }
          }
        }
      });

      console.log(`world: config=${JSON.stringify(world.defaultConfig)}`);

    	world.registerCellType('paper', {
        getCellValue: function () {
          return this.value;
    		},
        getCellNextValue: function () {
          return this.next;
    		},
        sanityCheckValue: function() {
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          function thisError(msg){
            throw new Error(`ERROR: (${this.x}, ${this.y}): ${msg}`);
          }
          if (thisValuePaperSpot.waterAmount < 0) { thisError(`thisValuePaperSpot.waterAmount < 0, ${thisValuePaperSpot.waterAmount}`); }
          if (thisValueWaterSpot.waterAmount < 0) { thisError(`thisValueWaterSpot.waterAmount < 0, ${thisValueWaterSpot.waterAmount}`); }
          for (var d = 0; d < DYES.length; d++) {
            if (thisValuePaperSpot.dyeAmounts[d] < 0) { thisError(`thisValuePaperSpot.dyeAmounts[${d}]<0, ${thisValuePaperSpot.dyeAmounts[d]}`); }
            if (thisValueWaterSpot.dyeAmounts[d] < 0) { thisError(`thisValueWaterSpot.dyeAmounts[${d}]<0, ${thisValueWaterSpot.dyeAmounts[d]}`); }
          }
        },
        absorption: function (neighbors) {
          // - some of the current surface water (plus the associated dyes) get absorbed
          //    - capacity of paper
          //    - Rf for the dyes? Dyes get concentrated in remaining/reducing surface water?
          //    - some dyes get absorbed 'deeper' into the paper?

          const thisNextWaterSpot  = this.next.waterSpot;
          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          if (thisValueWaterSpot.waterAmount > 0) {
            const remainingPaperWaterCapacity = thisValuePaperSpot.MaxWaterCapacity - thisValuePaperSpot.waterAmount;
            if (remainingPaperWaterCapacity > 0) {
              const waterAmountToBeAbsorbed = Math.min(thisValueWaterSpot.waterAmount, thisValuePaperSpot.WaterAbsorptionRate, remainingPaperWaterCapacity) * world.PaperAbsorptionFactor;
              const proportionWaterAmountToBeAbsorbed = (waterAmountToBeAbsorbed / thisValueWaterSpot.waterAmount);
              // transfer water: add to paper, remove from water
              thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount + waterAmountToBeAbsorbed;
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - waterAmountToBeAbsorbed;

              // transfer dyes: add to paper, remove from water
              for (var d = 0; d < DYES.length; d++) {
                const flowProportion = (proportionWaterAmountToBeAbsorbed == 1)? 1 : proportionWaterAmountToBeAbsorbed * DYES[d].Rf;
                const flowAmount = flowProportion * thisValueWaterSpot.dyeAmounts[d];
                thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] + flowAmount;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] - flowAmount;
              }
            }
          }

          return true;
        },
    		surfaceFlow: function (neighbors) {
          // - remaining surface water can flow (and splodge) from/to here, taking into account
          //    - when both cells are wet, flow towards midpoint of water amounts
          //    - when both cells are dry, nothing happens
          //    - when one cell is wet, the other dry, the wet one flows into the dry one if there is a min amount
          //    - if there is a slope, the min amount is adjusted accordingly (down for downhill, up for uphill)
          //    - dividing any amounts by 8
          //    - surface characteristics? could adjust the min height amount...
          //    - dyes flow in the same proportion as the water

          const thisNextWaterSpot  = this.next.waterSpot;
          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          function flowWithNhbr(direction, factorForMinHeight){
            // factorForMinHeight is factor when calculated from this cell.
            // - to multiply world.SpreadMinAmountToGoToDry
            // - Invert if from nhbr.

            const nhbr = neighbors[direction.index];

            // return as soon as we work out no flow will happen

            let nhbrValueWaterSpot;
            let nhbrValueWaterSpotWaterAmount = 0;
            if (nhbr) {
              nhbrValueWaterSpot            = nhbr.value.waterSpot;
              nhbrValueWaterSpotWaterAmount = nhbrValueWaterSpot.waterAmount;
            }
            // skip if both cells are dry, or here is dry and there is no nhbr
            if ((thisValueWaterSpot.waterAmount == 0) && ((!nhbr) || (nhbrValueWaterSpotWaterAmount == 0))) {
              return;
            }

            // return if either nhbr is empty, and the other is not wet enough
            if (thisValueWaterSpot.waterAmount == 0) {
              if (nhbrValueWaterSpotWaterAmount <= (world.SpreadMinAmountToGoToDry / factorForMinHeight)) {
                return;
              }
            } else if (nhbrValueWaterSpotWaterAmount == 0) {
              if (thisValueWaterSpot.waterAmount <= (world.SpreadMinAmountToGoToDry * factorForMinHeight) ) {
                return;
              }
            }

            // The amount to flow is half the difference,
            // divided by 8 because is only one of 8 different here<->nhbr interactions.
            // +ve means from here, -ve from nhbr.
            let waterAmountFlowing = (thisValueWaterSpot.waterAmount - nhbrValueWaterSpotWaterAmount) / (2 * 8) ;
            if (waterAmountFlowing == 0) {
              return;
            } else if (waterAmountFlowing > 0) { // from this cell to nhbr, so only record loss from this cell if there is no nhbr
              const proportionWaterAmountFlowing = waterAmountFlowing / thisValueWaterSpot.waterAmount;
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - waterAmountFlowing;
              if(!nhbr) { world.waterSpotLost.waterAmount = world.waterSpotLost.waterAmount + waterAmountFlowing; }

              // transfer dyes: in water
              for (var d = 0; d < DYES.length; d++) {
                const dyeAmountFlowing = thisValueWaterSpot.dyeAmounts[d] * proportionWaterAmountFlowing;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] - dyeAmountFlowing;
                if(!nhbr){ world.waterSpotLost.dyeAmounts[d] = world.waterSpotLost.dyeAmounts[d] + dyeAmountFlowing; }
              }
            } else { // waterAmountFlowing < 0, flowing from nhbr to this cell
              const waterAmountFlowingFromNhbr = - waterAmountFlowing;
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount + waterAmountFlowingFromNhbr;
              // transfer dyes: in water
              const proportionWaterAmountFlowing = waterAmountFlowingFromNhbr / nhbrValueWaterSpotWaterAmount;
              for (var d = 0; d < DYES.length; d++) {
                const dyeAmountFlowing = nhbrValueWaterSpot.dyeAmounts[d] * proportionWaterAmountFlowing;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] + dyeAmountFlowing;
              }
            }
          }

          // world.directions = [world.LEFT, world.RIGHT, world.BOTTOM, world.TOP, world.TOPLEFT, world.TOPRIGHT, world.BOTTOMLEFT, world.BOTTOMRIGHT];
          flowWithNhbr(world.LEFT       , 1                                       );
          flowWithNhbr(world.RIGHT      , 1                                       );
          flowWithNhbr(world.BOTTOM     ,    world.SpreadSlopeFactor              ); // BOTTOM is down
          flowWithNhbr(world.BOTTOMLEFT ,    world.SpreadSlopeFactor * Math.SQRT2 );
          flowWithNhbr(world.BOTTOMRIGHT,    world.SpreadSlopeFactor * Math.SQRT2 );
          flowWithNhbr(world.TOP        , 1/ world.SpreadSlopeFactor              );
          flowWithNhbr(world.TOPLEFT    , 1/(world.SpreadSlopeFactor * Math.SQRT2));
          flowWithNhbr(world.TOPRIGHT   , 1/(world.SpreadSlopeFactor * Math.SQRT2));

          return true;
        },
    		capillaryFlow: function (neighbors) {
          // -  water in paper will flow by capillary action, from high moisture to low
          //    - taking with it some dyes
          //    - only flows from/to a extant nhbr

          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          const remainingPaperWaterCapacity = thisValuePaperSpot.MaxWaterCapacity - thisValuePaperSpot.waterAmount;
          for (direction of world.directions) {
            let nhbr = neighbors[direction.index];
            if (!nhbr) { continue; }
            let nhbrValuePaperSpot = nhbr.value.paperSpot;
            let deltaWaterAmount = (thisValuePaperSpot.waterAmount - nhbrValuePaperSpot.waterAmount);
            let deltaWaterAmountScaled = deltaWaterAmount / (2 * 8);
            // +ve means from here, -ve from nhbr
            if (remainingPaperWaterCapacity > 0 && deltaWaterAmountScaled < 0) {
              let waterFlowAmount = Math.min(( - deltaWaterAmountScaled), remainingPaperWaterCapacity);
              thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount + waterFlowAmount;
              let waterFlowProportion = waterFlowAmount / nhbrValuePaperSpot.waterAmount;
              for (var d = 0; d < DYES.length; d++) {
                let dyeFlowAmount = waterFlowProportion * DYES[d].Rf * nhbrValuePaperSpot.dyeAmounts[d];
                thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] + dyeFlowAmount;
              }
            } else if(deltaWaterAmountScaled > 0) {
              let nhbrRemainingPaperWaterCapacity = nhbrValuePaperSpot.MaxWaterCapacity - nhbrValuePaperSpot.waterAmount;
              if (nhbrRemainingPaperWaterCapacity > 0) {
                let waterFlowAmount = Math.min(deltaWaterAmountScaled, nhbrRemainingPaperWaterCapacity);
                thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount - waterFlowAmount;
                let waterFlowProportion = waterFlowAmount / thisValuePaperSpot.waterAmount;
                for (var d = 0; d < DYES.length; d++) {
                  let dyeFlowAmount = waterFlowProportion * DYES[d].Rf * thisValuePaperSpot.dyeAmounts[d];
                  thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] - dyeFlowAmount;
                }
              }
            }

          }

          return true;
        },
    		diffusion: function (neighbors) {
          // - ink will diffuse, in wet paper
          //    - assume is related to relative concentrations, flowing from high to low (where both sides are wet)
          const thisNextWaterSpot  = this.next.waterSpot;
          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          if (thisValuePaperSpot.waterAmount > 0) {
            for (direction of world.directions) {
              let nhbr = neighbors[direction.index];
              if (!nhbr) { continue; }
              let nhbrValuePaperSpot = nhbr.value.paperSpot;
              if (nhbrValuePaperSpot.waterAmount <= 0) { continue; }

              for (var d = 0; d < DYES.length; d++) {
                let thisValueConcentration = thisValuePaperSpot.dyeAmounts[d] / thisValuePaperSpot.waterAmount;
                let nhbrValueConcentration = nhbrValuePaperSpot.dyeAmounts[d] / nhbrValuePaperSpot.waterAmount;
                let deltaConcentration = nhbrValueConcentration - thisValueConcentration;
                if (deltaConcentration > 0) { // dye comes to here
                  let dyeFlowAmount = DYES[d].Rd * ((deltaConcentration / nhbrValueConcentration) / 2) * nhbrValuePaperSpot.dyeAmounts[d] / 8;
                  thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] + dyeFlowAmount;
                } else if (deltaConcentration < 0) { // dye goes from here
                  let dyeFlowAmount = DYES[d].Rd * ((deltaConcentration / thisValueConcentration) / 2) * thisValuePaperSpot.dyeAmounts[d] / 8;
                  thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] + dyeFlowAmount;
                }
              }
            }
          }

          return true;
        },
    		evaporation: function (neighbors) {
          // - paper will dry out as water evaporates
          //    - assume will not evaporate from paper if water on surface
          //    - for simplicity, apply evaporation to computed Next, otherwise needs to be included in all other calculations
          //    - handle when there are dyes in surface water which fully evaporates

          const thisNextWaterSpot  = this.next.waterSpot;
          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          if (thisValueWaterSpot.waterAmount > 0) {
            let evapAmount = Math.min(thisValueWaterSpot.waterAmount, world.EvaporationFromSurfaceRate);
            if (evapAmount > 0) {
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - evapAmount;
              world.waterEvaporationFromSurface.waterAmount = world.waterEvaporationFromSurface.waterAmount + evapAmount;
              if (thisNextWaterSpot.waterAmount == 0) {
                thisNextPaperSpot.addDroplet(thisNextWaterSpot);
                thisNextWaterSpot.dyeAmounts.fill(0);
              }
            }
          }
          else
          if (thisValuePaperSpot.waterAmount > 0) {
            let evapAmount = Math.min(thisValuePaperSpot.waterAmount, world.EvaporationFromPaperRate);
            thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount - evapAmount;
            world.waterEvaporationFromPaper.waterAmount = world.waterEvaporationFromPaper.waterAmount + evapAmount;
          }

          return true;
        },
    		reset: function () {
          let oldPrev = this.prev; // don't discard the old value
  				this.prev   = this.value;
  				this.value  = this.next;
          this.next   = oldPrev;
          this.next.copy(this.value); // so adds and deletes happen in the .next value
    			return true;
    		}
    	}, function (x,y) {
    		//init
        this.value = new CellSpot();
        this.prev  = new CellSpot();
    		this.next  = new CellSpot();
        this.x = x;
        this.y = y;
    	});

    	world.initialize([
    		{ name: 'paper', distribution: 100 }
    	]);

    	return world;
    }

    function createPaper(canvas, maxIterations=100){

        function convertWorldGridToGridOfDyeAmounts(world){
          var worldGrid = world.grid;
          var gridOfDyeAmounts = [];

          // imageData reads from top left to bottom right
          // world reads from bottom left to top right (I think)

          for (var x = 0; x < world.width; x++) {
            var col = [];
            gridOfDyeAmounts.push(col);
            for (var y = 0; y < world.height; y++) {
              col.push( worldGrid[y][x].getCellValue().paperSpot.dyeAmounts);
            }
          }

          return gridOfDyeAmounts;
        }

        function calcDyeAndWaterTotalsInWorld(world){
          const worldGrid = world.grid;
          const dyeAmountsInPaper    = DYES.newEmptyDyeAmounts();
          const dyeAmountsInWater    = DYES.newEmptyDyeAmounts();
          let waterAmountInPaper   = 0;
          let waterAmountOnSurface = 0;

          for (var x = 0; x < world.width; x++) {
            for (var y = 0; y < world.height; y++) {
              let cell = worldGrid[y][x].getCellNextValue();
              DYES.addAmounts(cell.paperSpot.dyeAmounts, dyeAmountsInPaper);
              DYES.addAmounts(cell.waterSpot.dyeAmounts, dyeAmountsInWater);
              waterAmountInPaper   = waterAmountInPaper   + cell.paperSpot.waterAmount;
              waterAmountOnSurface = waterAmountOnSurface + cell.waterSpot.waterAmount;
            }
          }

          const dyeAmountsTotal = DYES.newEmptyDyeAmounts();
          DYES.addAmounts(dyeAmountsInPaper, dyeAmountsTotal);
          DYES.addAmounts(dyeAmountsInWater, dyeAmountsTotal);
          DYES.addAmounts(world.waterSpotLost.dyeAmounts, dyeAmountsTotal);
          DYES.subtractAmounts(world.waterDropletsAddedToSurface.dyeAmounts, dyeAmountsTotal);
          const dyeAmountTotal = dyeAmountsTotal.reduce( (prev, curr) => prev + curr );
          const waterAmountTotal = [
            waterAmountInPaper,
            waterAmountOnSurface,
            world.waterSpotLost.waterAmount,
            world.waterEvaporationFromPaper.waterAmount,
            world.waterEvaporationFromSurface.waterAmount
          ].reduce( (prev, curr) => prev + curr ) - world.waterDropletsAddedToSurface.waterAmount;

          return {
            waterAmountTotal    : waterAmountTotal,
            waterAmountInPaper  : waterAmountInPaper,
            waterAmountOnSurface: waterAmountOnSurface,
            waterAmountInPaperOrOnSurface: waterAmountInPaper + waterAmountOnSurface,
            waterAmountLost     : world.waterSpotLost.waterAmount,
            waterAmountEvaporationFromPaper   : world.waterEvaporationFromPaper.waterAmount,
            waterAmountEvaporationFromSurface : world.waterEvaporationFromSurface.waterAmount,
            waterDropletsAddedToSurface : world.waterDropletsAddedToSurface.waterAmount,
              dyeAmountTotal    :   dyeAmountTotal,
              dyeAmountsTotal   :   dyeAmountsTotal,
              dyeAmountsInPaper :   dyeAmountsInPaper,
              dyeAmountsInWater :   dyeAmountsInWater,
              dyeAmountsLost    : world.waterSpotLost.dyeAmounts,
                      stepCount : world.stepCount
          }
        }

        function calcDyeAndWaterTotalDelta(totalsList, relative=true){
          const first = (relative)? totalsList[totalsList.length - 2] : totalsList[0];
          const last  = totalsList[totalsList.length - 1];
          return {
              stepCountDelta : last.stepCount - first.stepCount + ((relative)? 0 : 1),
            waterAmountTotal : (last.waterAmountTotal - first.waterAmountTotal).toFixed(5),
              dyeAmountTotal : (last.dyeAmountTotal - first.dyeAmountTotal).toFixed(5),
          }
        }

        function createPaperAddDropsAndRun() {
          const context = canvas.getContext('2d');
          console.log(`canvas.width=${canvas.width}, canvas.height=${canvas.height}`);
          const imageData = context.getImageData(0,0,canvas.width,canvas.height);
          const world = createWorldOfBlottingPaperAndDyes(imageData.width, imageData.height);

          let numIterations=1;
          let batchSize = 10;
          const startOverallRunTimeMillis = Date.now();
          let   startBatchRunTimeMillis   = Date.now();
          const minAcceptableDelta = 0.1;

          let totals = calcDyeAndWaterTotalsInWorld(world);
          console.log(`iteration=0,`);
          // console.log(`     totals=${JSON.stringify(totals)}`);
          const totalsList = [totals];

          function calcAndDisplayTotals(relative=true){
            let fromTimeMillis = (relative)? startBatchRunTimeMillis : startBatchRunTimeMillis;
            let fromIndex      = (relative && totalsList.length > 2)? totalsList.length - 2   : 0;

            let nowMillis = Date.now();
            let frameRate = batchSize / ((nowMillis - fromTimeMillis) / 1000);
            let pixelRate = batchSize * world.width * world.height / ((nowMillis - startBatchRunTimeMillis) / 1000);
            let totals = calcDyeAndWaterTotalsInWorld(world);
            totalsList.push(totals);
            console.log(`iteration=${numIterations}, frames/s=${frameRate.toFixed(2)}, pixels/s=${pixelRate.toFixed(0)}, waterAmountRemaining=${totals.waterAmountInPaperOrOnSurface.toFixed(1)}`);
            if (totalsList.length > 1) {
              const totalsDelta = calcDyeAndWaterTotalDelta(totalsList, relative);
              if (Math.abs(totalsDelta.waterAmountTotal) > minAcceptableDelta || Math.abs(totalsDelta.dyeAmountTotal) > minAcceptableDelta) {
                console.log(`WARNING: delta error > ${minAcceptableDelta}
                  prev: ${JSON.stringify(totalsList[fromIndex])}
                  last: ${JSON.stringify(totalsList[totalsList.length - 1])}`);
                  console.log(`       totalsDelta=${JSON.stringify(totalsDelta)}`);
              }
              if (relative) {
                startBatchRunTimeMillis = nowMillis;
              }
            }
          }

          function iterateAndDisplayWorld(){
            // console.log(`world iteration=${numIterations} of ${maxIterations}`);
            world.stepWithCount();
            let gridOfDyeAmounts = convertWorldGridToGridOfDyeAmounts(world);
            DYES.writeGridOfDyeAmountsToImageData(gridOfDyeAmounts, imageData);
            context.putImageData(imageData, 0, 0);

            if ((numIterations % batchSize == 0) || numIterations==1 ) {
              calcAndDisplayTotals();
            }

            numIterations = numIterations + 1;
            const lastTotals = totalsList[totalsList.length -1];
            const waterRemaining = lastTotals.waterAmountInPaper + lastTotals.waterAmountOnSurface;
            if (   (numIterations >= maxIterations)
                || ((numIterations > batchSize) && (waterRemaining <= 0))
              ) {
                const relative = true;
                calcAndDisplayTotals(!relative);
                console.log(`iterations ended.`);
                window.dispatchEvent( new Event('StopRecording') );
            } else {
              window.requestAnimationFrame(iterateAndDisplayWorld);
            }
          }

          // always have a drop on (1,1) for debugging
          world.addBigDrop(
            1,
            1,
            10+(Math.random()*20),
            WaterSpot.createBigRandomDrop()
          );

          const numDropsAcross = 10;
          const dropSpacing = world.width / (numDropsAcross+1);
          for (var i = 0; i < numDropsAcross; i++) {
            let x = world.width * Math.random();
            let y = world.height * Math.random();
            let r = 2+(Math.random()*world.width)/3;
            let h = 0.1 + Math.random()*4;
            let v = Math.PI * r * r * h;
            world.addBigDrop(x, y, r, WaterSpot.createBigRandomDrop(v));
          }

          iterateAndDisplayWorld();
        }

        return {
          run: createPaperAddDropsAndRun
        }
    }

    return {
      create: createPaper
    }
  })();
  </script>
</head>

<body>
  <h1>Chromatography</h1>

    <canvas class="blotting-paper" id="myCanvas" width="100" height="100"></canvas>

  <script>
  (function(){
    const codeVersion = '2-0'; // affects filename of recording
    const maxIterations = 2000;

    const canvas = document.getElementById('myCanvas');
    const context = canvas.getContext('2d');

    {
      /* set up the recording of the canvas animations */
      const mimeType = 'video/webm'; // couldn't find a different format which worked, e.g. mp4.
      const options = {mimeType: mimeType};
      const recordedFile = `chromatography-experiment.${codeVersion}.webm`;
      function download(event) { // receives the recorded data, and writes to file using a url hack. Ick.
        const videoData = [ event.data ];
        const blob = new Blob(videoData, {
          type: mimeType
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        document.body.appendChild(a);
        a.style = 'display: none';
        a.href = url;
        a.download = recordedFile;
        a.click();
        window.URL.revokeObjectURL(url);
      }
      const frameRate = 15;
      const stream = canvas.captureStream(frameRate);
      const mediaRecorder = new MediaRecorder(stream, options);
      mediaRecorder.ondataavailable = download;
      mediaRecorder.start();
      // window.addEventListener('StopRecording', e => { mediaRecorder.stop(); })
    }

    {
      // paper starts clean and dry
      var paper = Chroma.create(canvas, maxIterations);
      window.setTimeout(paper.run, 100);
    }
  })();
  </script>
</body>
</html>
