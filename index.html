<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Chromatography</title>
  <style>
  .blotting-paper {
    border-width: 1px;
    border-color: lightgrey;
    border-style: solid;

    box-shadow: 10px 10px 5px #888888;
  }
  </style>
  <script src="assets/cellauto.min.js"></script>
  <script>
  const Chroma = (function(){

    function invertData( data ) {
      for (var i = 0; i < data.length; i += 4) {
        data[i]     = 255 - data[i];     // red
        data[i + 1] = 255 - data[i + 1]; // green
        data[i + 2] = 255 - data[i + 2]; // blue
      }
    }

    function createWorldOfExampleSplashes(width, height) {
      // copied from http://sanojian.github.io/cellauto/#usage
    	world = new CAWorld({
    		width: Math.floor(width),
    		height: Math.floor(height),
    	});

    	world.palette = [];
    	var colors = [];
    	for (var index=0; index<64; index++) {
    		world.palette.push('30, 0, 0, ' + index/64);
    		colors[index] = 63 - index;
    	}

    	world.registerCellType('water', {
    		getColor: function () {
    			var v = (Math.max(2 * this.value + 0.02, 0) - 0.02) + 0.5;
    			return colors[Math.floor(colors.length * v)];
    		},
    		process: function (neighbors) {
    			if(this.droplet == true) {
    				for (var i = 0; i < neighbors.length; i++) {
    					if (neighbors[i] !== null && neighbors[i].value) {
    						neighbors[i].value = 0.5 *this.value;
    						neighbors[i].prev = 0.5 *this.prev;
    					}
    				}
    				this.droplet = false;
    				return true;
    			}
    			var avg = this.getSurroundingCellsAverageValue(neighbors, 'value');
    			this.next = 0.99 * (2 * avg - this.prev);
    			return true;
    		},
    		reset: function () {
    			if(Math.random() > 0.9999) {
    				this.value = -0.2 + 0.25*Math.random();
    				this.prev = this.value;
    				this.droplet = true;
    			}
    			else {
    				this.prev = this.value;
    				this.value = this.next;
    			}
    			return true;
    		}
    	}, function (x,y) {
    		//init
    		this.water = true;
    		this.value = 0.0;
    		this.prev = this.value;
    		this.next = this.value;

        // if (x == y) {
        //   console.log(`in init: x==y==${x}`);
        // }
    	});

    	world.initialize([
    		{ name: 'water', distribution: 100 }
    	]);

    	return world;
    }

    function constructColorPaletteFromWorld( world ){
      // construct palette arrays from world palette CSVs
      const palette = [];
      for (var p = 0; p < world.palette.length; p++) {
        const colorsCSV = world.palette[p];
        const colors = colorsCSV.split(', ');
        colors[3] = Math.floor(colors[3] * 255);
        palette.push(colors);
      }

      return palette;
    }

    function writeWorldCellsToImageData( world, imageData, palette, cellSize ){
      const data = imageData.data;

      for (var y=0; y<world.height; y++) {
        for (var x=0; x<world.width; x++) {
          var cell = world.grid[y][x];
          var colorIndex = cell.getColor();
          var colors = palette[colorIndex];
          for (var sx = 0; sx < cellSize; sx++) {
            for (var sy = 0; sy < cellSize; sy++) {
              for (var c = 0; c < 4; c++) {
                var dataCellIndex = 4 * (((x*cellSize)+sx) + (((y*cellSize)+sy) * imageData.width));
                data[dataCellIndex+c] = colors[c];
              }
            }
          }
        }
      }
    }

    function createPaper(canvas){
        function addSolvent() {
          const cellSize = 2;
          const maxIterations = 100;
          const pausePerFrame = 10;

          const context = canvas.getContext('2d');
          console.log(`canvas.width=${canvas.width}, canvas.height=${canvas.height}`);
          const imageData = context.getImageData(0,0,canvas.width,canvas.height);
          const world = createWorldOfExampleSplashes(canvas.width/cellSize, canvas.height/cellSize);
          const palette = constructColorPaletteFromWorld(world);

          console.log(`world.width=${world.width}, world.height=${world.height}`);
          console.log(`world.palette.length=${world.palette.length}`);

          function iterateAndDisplayWorld( numIterations=1 ){
            // console.log(`world iteration=${numIterations} of ${maxIterations}`);
            world.step();
            writeWorldCellsToImageData( world, imageData, palette, cellSize );
            context.putImageData(imageData, 0, 0);

            if (numIterations < maxIterations) {
              window.setTimeout(function(){ iterateAndDisplayWorld(numIterations+1); }, pausePerFrame);
            } else {
              console.log(`ending on world iteration=${numIterations} of ${maxIterations}`);
            }
          }

          iterateAndDisplayWorld();
        }

        return {
          run: addSolvent
        }
    }

    return {
      create: createPaper
    }
  })();
  </script>
</head>

<body>
  <h1>Chromatography</h1>

    <canvas class="blotting-paper" id="myCanvas" width="400" height="400"></canvas>

  <script>
    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');
    var imageObj = new Image();

    imageObj.onload = function() {
      context.drawImage(imageObj, 0, 0);
      var paper = Chroma.create(canvas);
      window.setTimeout(paper.run, 100);
    };
    imageObj.src = 'assets/splodge.png';
  </script>
</body>
</html>
