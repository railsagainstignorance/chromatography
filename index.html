<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Chromatography</title>
  <style>
  .blotting-paper {
    border-width: 1px;
    border-color: lightgrey;
    border-style: solid;

    box-shadow: 10px 10px 5px #888888;
  }
  </style>
  <script src="assets/cellauto.min.js"></script>
  <script>
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  </script>
  <script>
  const Chroma = (function(){

    const DYES = [
      {
        name: 'red',
          Rf: 0.4,  // propensity to go with the flow
          Rd: 0.05, // propensity to 'bleed' if no flow
          RGBPattern: [1.0, 0, 0], // how to read it's value from/to RGB triple
      },
      {
        name: 'green',
          Rf: 0.5,
          Rd: 0.07,
          RGBPattern: [0, 1.0, 0],
      },
      {
        name: 'blue',
          Rf: 0.6,
          Rd: 0.09,
          RGBPattern: [0, 0, 1.0],
      },
    ];

    DYES.splitRgbaPixelIntoDyes = function(rgba) {
      // assume rgba is [R,G,B, A], each 0-255
      // use A to dilute dye amounts
      // assume full white [255,255,255], or full transparent, has no dyes at all
      // return array of dye amounts, min 0, max 1.0

      var dyeAmounts = new Array(this.length);

      if ( rgba[3]==0 || (rgba[0]==255 && rgba[1]==255 && rgba[2]==255)) {
        dyeAmounts.fill(0);
      } else {
        for (var d = 0; d < this.length; d++) {
          let tot = 0;
          for (var i = 0; i < 3; i++) {
            tot = tot + (rgba[i] * this[d].RGBPattern[i] / 255);
          }
          tot = tot * (rgba[3] / 255);
          dyeAmounts[d] = Math.min(tot, 1.0);
        }
      }
      return dyeAmounts;
    }

    DYES.combineDyesIntoRgbaPixel = function(dyeAmounts) {
      // return [R, G, B, A]
      // assume no dyes => full white

      var rgba = new Array(4); // calc 0-1.0 range, then convert to 0-255 later

      const sumDyeAmounts = dyeAmounts.reduce(( acc, cur ) => acc + cur, 0);
      if (sumDyeAmounts == 0) {
        rgba.fill(1);
      } else {
        rgba.fill(0);
        for (var d = 0; d < this.length; d++) {
          for (var i = 0; i < 3; i++) {
            rgba[i] = rgba[i] + (dyeAmounts[d] * this[d].RGBPattern[i]);
          }
        }
        rgba[3] = 1;
      }

      rgba = rgba.map(c => {return (c>1.0)? 255 : Math.floor(c * 255);});
      return rgba;
    }

    {
      let testRgbaPixels = [
        [ [0,0,0,0], [255,255,255,255] ],
        [ [255,255,255,255], [255,255,255,255] ],
        [ [255,0,0,255], [255,0,0,255] ],
        [ [0,255,0,255], [0,255,0,255] ],
        [ [0,0,255,255], [0,0,255,255] ],
        [ [255,255,0,255], [255,255,0,255] ],
        [ [10,11,12,255], [10,11,12,255] ],
      ];

      for (var p = 0; p < testRgbaPixels.length; p++) {
        let fromPixel = testRgbaPixels[p][0];
        let toPixel   = testRgbaPixels[p][1];
        let dyeAmounts = DYES.splitRgbaPixelIntoDyes( fromPixel );
        let outputPixel  = DYES.combineDyesIntoRgbaPixel( dyeAmounts );
        for (var i = 0; i < fromPixel.length; i++) {
          if (toPixel[i] !== outputPixel[i]) {
            throw new Error(`Error: converting pixel to dyes and back: fromPixel=${fromPixel}, toPixel=${toPixel}, but outputPixel=${outputPixel}, and dyeAmounts=${dyeAmounts}`);
          }
        }
      }
    }

    DYES.convertImageDataIntoGridOfDyeAmounts = function(imageData){
      const data = imageData.data;
      const grid = [];

      for (var x = 0; x < imageData.width; x++) {
        let col = [];
        grid.push(col);
        for (var y = 0; y < imageData.height; y++) {
          let imageDataCellIndex = 4 * (x + (y * imageData.width));
          let rgba = data.slice(imageDataCellIndex, imageDataCellIndex + 4);
          let dyeAmounts = this.splitRgbaPixelIntoDyes(rgba);
          col.push(dyeAmounts);
        }
      }

      return grid;
    }

    DYES.writeGridOfDyeAmountsToImageData = function(grid, imageData){
      if ((imageData.width !== grid.length) || (imageData.height !== grid[0].length)) {
        throw new Error(`Error: mismatch found between size of grid and imageData`);
      }
      const data = imageData.data;

      for (var x=0; x<imageData.width; x++) {
        for (var y=0; y<imageData.height; y++) {
          var cell = grid[x][y];
          var dyeAmounts = cell.getDyeAmounts();
          var rgba = this.combineDyesIntoRgbaPixel(dyeAmounts);
          var dataCellIndex = 4 * (x + (y * imageData.width));
          for (var i = 0; i < 4; i++) {
            data[dataCellIndex+i] = rgba[i];
          }
        }
      }

      return imageData;
    }

    function createWorldOfBlottingPaperAndDyes(width, height, gridOfDyeAmounts) {
    	world = new CAWorld({
    		width: Math.floor(width),
    		height: Math.floor(height),
    	});

    	world.registerCellType('paper', {
    		getDyeAmounts: function () {
          return this.value;
    		},
    		process: function (neighbors) {
    			// if(this.droplet == true) {
    			// 	for (var i = 0; i < neighbors.length; i++) {
    			// 		if (neighbors[i] !== null && neighbors[i].value) {
    			// 			neighbors[i].value = 0.5 *this.value;
    			// 			neighbors[i].prev = 0.5 *this.prev;
    			// 		}
    			// 	}
    			// 	this.droplet = false;
    			// 	return true;
    			// }
    			// var avg = this.getSurroundingCellsAverageValue(neighbors, 'value');
    			// this.next = 0.99 * (2 * avg - this.prev);

          // do clever flow stuff here

          for (var d = 0; d < DYES.length; d++) {
            this.next[d] = this.value[d] * (1 - DYES[d].Rf);
            if (neighbors[world.TOP.index] !== null) {
              this.next[d] = this.next[d] + (neighbors[world.TOP.index].value[d] * DYES[d].Rf);
            }
          }

    			return true;
    		},
    		reset: function () {
  				this.prev  = this.value;
  				this.value = this.next;
          this.next  = this.next.slice(0);
    			return true;
    		}
    	}, function (x,y) {
    		//init
        this.value = gridOfDyeAmounts[y][x].slice(0);
        this.prev = this.value.slice(0);
    		this.next = this.value.slice(0);
    	});

    	world.initialize([
    		{ name: 'paper', distribution: 100 }
    	]);

    	return world;
    }

    function createPaper(canvas){
        function addSolvent() {
          const maxIterations = 100;
          const context = canvas.getContext('2d');
          console.log(`canvas.width=${canvas.width}, canvas.height=${canvas.height}`);
          const imageData = context.getImageData(0,0,canvas.width,canvas.height);
          const gridOfDyeAmounts = DYES.convertImageDataIntoGridOfDyeAmounts(imageData);
          const world = createWorldOfBlottingPaperAndDyes(imageData.width, imageData.height, gridOfDyeAmounts);
          console.log(`world.width=${world.width}, world.height=${world.height}`);

          var numIterations=1;

          function iterateAndDisplayWorld(){
            // console.log(`world iteration=${numIterations} of ${maxIterations}`);
            world.step();
            DYES.writeGridOfDyeAmountsToImageData(world.grid, imageData);
            context.putImageData(imageData, 0, 0);

            numIterations = numIterations + 1;
            if (numIterations < maxIterations) {
              window.requestAnimationFrame(iterateAndDisplayWorld);
            } else {
              console.log(`ending on world iteration=${numIterations} of ${maxIterations}`);
            }
          }

          iterateAndDisplayWorld();
        }

        return {
          run: addSolvent
        }
    }

    return {
      create: createPaper
    }
  })();
  </script>
</head>

<body>
  <h1>Chromatography</h1>

    <canvas class="blotting-paper" id="myCanvas" width="400" height="400"></canvas>

  <script>
    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');
    var imageObj = new Image();

    imageObj.onload = function() {
      context.drawImage(imageObj, 0, 0);
      var paper = Chroma.create(canvas);
      window.setTimeout(paper.run, 100);
    };
    imageObj.src = 'assets/splodge.png';
  </script>
</body>
</html>
