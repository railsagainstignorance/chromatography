<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Chromatography</title>
  <style>
  .blotting-paper {
    border-width: 1px;
    border-color: lightgrey;
    border-style: solid;

    box-shadow: 10px 10px 5px #888888;
  }
  </style>
  <script src="assets/cellauto.min.js"></script>
  <script>
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  </script>
  <script>
  const Chroma = (function(){

    const dyes = [
      {
        name: 'red',
          Rf: 0.4,  // propensity to go with the flow
          Rd: 0.05, // propensity to 'bleed' if no flow
          RGBPattern: [1.0, 0, 0], // how to read it's value from/to RGB triple
      },
      {
        name: 'green',
          Rf: 0.5,
          Rd: 0.07,
          RGBPattern: [0, 1.0, 0],
      },
      {
        name: 'blue',
          Rf: 0.6,
          Rd: 0.09,
          RGBPattern: [0, 0, 1.0],
      },
    ];

    dyes.splitRgbaPixelIntoDyes = function(rgba) {
      // assume rgba is [R,G,B, A], each 0-255
      // use A to dilute dye amounts
      // assume full white [255,255,255], or full transparent, has no dyes at all
      // return array of dye amounts, min 0, max 1.0

      var dyeAmounts = new Array(this.length);

      if ( rgba[3]==0 || (rgba[0]==255 && rgba[1]==255 && rgba[2]==255)) {
        dyeAmounts.fill(0);
      } else {
        for (var d = 0; d < this.length; d++) {
          let tot = 0;
          for (var i = 0; i < 3; i++) {
            tot = tot + (rgba[i] * this[d].RGBPattern[i]);
          }
          tot = tot * rgba[3] / 255;
          dyeAmounts[d] = Math.min(tot, 1.0);
        }
      }
      return dyeAmounts;
    }

    dyes.combineDyesIntoRgbaPixel = function(dyeAmounts) {
      // return [R, G, B, A]
      // assume no dyes => full white

      const rgba = new Array(4); // calc 0-1.0 range, then convert to 0-255 later

      const sumDyeAmounts = dyeAmounts.reduce(( acc, cur ) => acc + cur, 0);
      if (sumDyeAmounts == 0) {
        rgba.fill(1);
      } else {
        rgba.fill(0);
        for (var d = 0; d < this.length; d++) {
          for (var i = 0; i < 3; i++) {
            rgba[i] = rgba[i] + (dyeAmounts[d] * this[d].RGBPattern[i]);
          }
        }
        rgba[3] = 1;
      }

      rgba = rgba.map(c => {return (c>1.0)? 255 : Math.floor(c * 255);});
      return rgba;
    }

    function createWorldOfExampleSplashes(width, height, imageData, cellSize) {
      const data = imageData.data; // starting data lifted from image

      // copied from http://sanojian.github.io/cellauto/#usage
    	world = new CAWorld({
    		width: Math.floor(width),
    		height: Math.floor(height),
    	});

    	world.palette = [];
    	var colors = [];
    	for (var index=0; index<64; index++) {
    		world.palette.push('30, 0, 0, ' + index/64);
    		colors[index] = 63 - index;
    	}

    	world.registerCellType('water', {
    		getColor: function () {
    			var v = (Math.max(2 * this.value + 0.02, 0) - 0.02) + 0.5;
          if (v >= 1.0) {
            v = 0.999;
          }
          var color = colors[Math.floor(colors.length * v)];
          return color;
    		},
    		process: function (neighbors) {
    			if(this.droplet == true) {
    				for (var i = 0; i < neighbors.length; i++) {
    					if (neighbors[i] !== null && neighbors[i].value) {
    						neighbors[i].value = 0.5 *this.value;
    						neighbors[i].prev = 0.5 *this.prev;
    					}
    				}
    				this.droplet = false;
    				return true;
    			}
    			var avg = this.getSurroundingCellsAverageValue(neighbors, 'value');
    			this.next = 0.99 * (2 * avg - this.prev);
    			return true;
    		},
    		reset: function () {
    			if(Math.random() > 0.9999) {
    				this.value = -0.2 + 0.25*Math.random();
    				this.prev = this.value;
    				this.droplet = true;
    			}
    			else {
    				this.prev = this.value;
    				this.value = this.next;
    			}
    			return true;
    		}
    	}, function (x,y) {
    		//init
    		this.water = true;

        const imageDataCellIndex = 4 * ((x*cellSize) + ((y*cellSize) * imageData.width));
        const pickRed = data[imageDataCellIndex];

    		this.value = (pickRed/255)/4 - 0.2;
        // console.log(`cell.init: pickRed=${pickRed}, this.value=${this.value}`);

        this.prev = this.value;
    		this.next = this.value;
    	});

    	world.initialize([
    		{ name: 'water', distribution: 100 }
    	]);

    	return world;
    }

    function constructColorPaletteFromWorld( world ){
      // construct palette arrays from world palette CSVs
      const palette = [];
      for (var p = 0; p < world.palette.length; p++) {
        const colorsCSV = world.palette[p];
        const colors = colorsCSV.split(', ');
        colors[3] = Math.floor(colors[3] * 255);
        palette.push(colors);
      }

      return palette;
    }

    function writeWorldCellsToImageData( world, imageData, palette, cellSize ){
      const data = imageData.data;

      for (var y=0; y<world.height; y++) {
        for (var x=0; x<world.width; x++) {
          var cell = world.grid[y][x];
          var colorIndex = cell.getColor();
          var colors = palette[colorIndex];
            if (! colors) {
              console.log(`writeWorldCellsToImageData: colorIndex=${colorIndex}, colors=${colors}`);
            }
          for (var sx = 0; sx < cellSize; sx++) {
            for (var sy = 0; sy < cellSize; sy++) {
              for (var c = 0; c < 4; c++) {
                var dataCellIndex = 4 * (((x*cellSize)+sx) + (((y*cellSize)+sy) * imageData.width));
                data[dataCellIndex+c] = colors[c];
              }
            }
          }
        }
      }
    }

    function createPaper(canvas){
        function addSolvent() {
          const cellSize = 2;
          const maxIterations = 100;
          const pausePerFrame = 10;

          const context   = canvas.getContext('2d');
          console.log(`canvas.width=${canvas.width}, canvas.height=${canvas.height}`);
          const imageData = context.getImageData(0,0,canvas.width,canvas.height);
          const     world = createWorldOfExampleSplashes(canvas.width/cellSize, canvas.height/cellSize, imageData, cellSize);
          const   palette = constructColorPaletteFromWorld(world);

          console.log(`world.width=${world.width}, world.height=${world.height}`);
          console.log(`world.palette.length=${world.palette.length}`);

          var numIterations=1;

          function iterateAndDisplayWorld(){
            // console.log(`world iteration=${numIterations} of ${maxIterations}`);
            world.step();
            writeWorldCellsToImageData( world, imageData, palette, cellSize );
            context.putImageData(imageData, 0, 0);

            numIterations = numIterations + 1;

            if (numIterations < maxIterations) {
              window.requestAnimationFrame(iterateAndDisplayWorld);
            } else {
              console.log(`ending on world iteration=${numIterations} of ${maxIterations}`);
            }
          }

          iterateAndDisplayWorld();
        }

        return {
          run: addSolvent
        }
    }

    return {
      create: createPaper
    }
  })();
  </script>
</head>

<body>
  <h1>Chromatography</h1>

    <canvas class="blotting-paper" id="myCanvas" width="400" height="400"></canvas>

  <script>
    var canvas = document.getElementById('myCanvas');
    var context = canvas.getContext('2d');
    var imageObj = new Image();

    imageObj.onload = function() {
      context.drawImage(imageObj, 0, 0);
      var paper = Chroma.create(canvas);
      window.setTimeout(paper.run, 100);
    };
    imageObj.src = 'assets/splodge.png';
  </script>
</body>
</html>
