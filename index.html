<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Chromatography</title>
  <style>
  .blotting-paper {
    border-width: 1px;
    border-color: lightgrey;
    border-style: solid;

    box-shadow: 10px 10px 5px #888888;

    background-color: white;
  }
  #myCanvas { // make them canvas pixels bigger. Assuming the canvas is 100x100, the pixels become 4x4
    width: 400px;
    height: 400px;
  }
  </style>
  <script src="assets/cellauto.min.js"></script>
  <script>
    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  </script>
  <script>
  const Chroma = (function(){

    const DYES = [
      {
        name: 'red',
          Rf: 0.2,  // propensity to go with the flow
          Rd: 0.07, // propensity to 'bleed' if no flow
          RGBPattern: [1.0, 0, 0], // how to read it's value from/to RGB triple
      },
      {
        name: 'green',
          Rf: 0.3,
          Rd: 0.075,
          RGBPattern: [0, 1.0, 0],
      },
      {
        name: 'blue',
          Rf: 0.4,
          Rd: 0.06,
          RGBPattern: [0, 0, 1.0],
      },
    ];

    {
      // check internal consistency of Rf and Rd

      let numDirections = 8;

      for( let dye of DYES ){
        if ( (dye.Rf + (numDirections * dye.Rd)) > 1.0 ) {
          throw new Error(`ERROR: Rf + numDirections*Rd >1.0 for name=${dye.name}, Rf=${dye.Rf}, Rd=${dye.Rd}, numDirections=${numDirections}`);
        }
      }
    }

    DYES.RGBMaximum = 253;

    DYES.newEmptyDyeAmounts = function() {
      return new Array(this.length).fill(0);
    }

    DYES.cloneAmounts = function(from) {
      return from.slice(0);
    }

    DYES.copyAmounts = function(from, to){
      for (var i = 0; i < this.length; i++) {
        to[i] = from[i];
      }
    }

    DYES.addAmounts = function(from, to){
      for (var i = 0; i < this.length; i++) {
        to[i] = to[i] + from[i];
      }
    }

    DYES.subtractAmounts = function(from, to){
      for (var i = 0; i < this.length; i++) {
        to[i] = to[i] - from[i];
      }
    }

    DYES.combineDyesIntoRgbaPixel = function(dyeAmounts) {
      // return [R, G, B, A]
      // assume no dyes => full white

      // calc 0-1.0 range, then convert to 0-255 later
      var rgba01 = new Array(3).fill(0);

      for (var d = 0; d < this.length; d++) {
        for (var i = 0; i < 3; i++) {
          rgba01[i] = rgba01[i] + (dyeAmounts[d] * this[d].RGBPattern[i]);
        }
      }

      var maxRGB01 = Math.max.apply(null, rgba01);
      if (maxRGB01 > 1.0) {
        rgba01 = rgba01.map(c => {return c/maxRGB01});
        maxRGB01 = 1.0;
      }
      rgba01.push(maxRGB01);
      if (maxRGB01 == 0) {
        rgba01.fill(1.0);
      }

      var rgba = rgba01.map(c => {return (c>1.0)? 255 : Math.floor(c * 255);});
      return rgba;
    }

    DYES.writeGridOfDyeAmountsToImageData = function(grid, imageData){
      if ((imageData.width !== grid.length) || (imageData.height !== grid[0].length)) {
        throw new Error(`Error: mismatch found between size of grid and imageData`);
      }
      const data = imageData.data;
      for (var x=0; x<imageData.width; x++) {
        for (var y=0; y<imageData.height; y++) {
          var dyeAmounts = grid[x][y];
          var rgba = this.combineDyesIntoRgbaPixel(dyeAmounts);
          var dataCellIndex = 4 * (x + (y * imageData.width));
          for (var i = 0; i < 4; i++) {
            data[dataCellIndex+i] = rgba[i];
          }
        }
      }
      return imageData;
    }

    //------------

    var PaperSpot = function(dyeAmounts, waterAmount){
      this.dyeAmounts  =  (dyeAmounts)? dyeAmounts.slice(0) : DYES.newEmptyDyeAmounts();
      this.waterAmount = (waterAmount)?        waterAmounts : 0;
    }

    PaperSpot.prototype = (function () {
      /* private members */
      let maxWaterCapacity = 1;
      /* public members */
      return {
           MaxWaterCapacity: maxWaterCapacity,
        WaterAbsorptionRate: 0.1,
                      clone: function(){ return new Paperspot(this.dyeAmounts, this.waterAmount); },
                  stringify: function(){ return JSON.stringify(this); },
                       copy: function(from){
                         this.waterAmount = from.waterAmount;
                         DYES.copyAmounts(from.dyeAmounts, this.dyeAmounts);
                       },
                 addDroplet: function(drop){
                    this.waterAmount = Math.min(this.waterAmount + drop.waterAmount, maxWaterCapacity);
                    for (var i = 0; i < this.dyeAmounts.length; i++) {
                      this.dyeAmounts[i] = this.dyeAmounts[i] + drop.dyeAmounts[i];
                    }
                    return this;
                  },
      };
    })();

    //------------

    var WaterSpot = function(waterAmount, dyeAmounts){
      this.waterAmount = (waterAmount)?         waterAmount : 0;
      this.dyeAmounts  =  (dyeAmounts)? dyeAmounts.slice(0) : DYES.newEmptyDyeAmounts();
    }

    WaterSpot.prototype = (function(){
      /* private members */

      /* public members */
      return {
             clone: function() { return new WaterSpot(this.waterAmount, this.dyeAmounts); },
        addDroplet: function(drop){
           this.waterAmount = this.waterAmount + drop.waterAmount;
           for (var i = 0; i < this.dyeAmounts.length; i++) {
             this.dyeAmounts[i] = this.dyeAmounts[i] + drop.dyeAmounts[i];
           }
           return this;
         },
          divideBy: function(n){
          this.waterAmount = this.waterAmount/n;
          for (var i = 0; i < this.dyeAmounts.length; i++) {
            this.dyeAmounts[i] = this.dyeAmounts[i] / n;
          }
          return this;
        },
         stringify: function(){ return JSON.stringify(this); },
              copy: function(from){
               this.waterAmount = from.waterAmount;
               DYES.copyAmounts(from.dyeAmounts, this.dyeAmounts);
              },
      };
    })();

    WaterSpot.createBigRedDrop = function() {
      const waterAmount = 1000.0;
      const dyeAmounts = DYES.newEmptyDyeAmounts();
      dyeAmounts[0] = 3000.0;
      const drop = new WaterSpot(waterAmount, dyeAmounts);
      return drop;
    }

    WaterSpot.createBigRandomDrop = function(volume=1) {
      const waterAmount = volume;
      const dyeAmounts = DYES.newEmptyDyeAmounts();
      for (var i = 0; i < dyeAmounts.length; i++) {
        dyeAmounts[i] = volume*3*Math.random();
      }
      const drop = new WaterSpot(waterAmount, dyeAmounts);
      return drop;
    }

    //------------

    var CellSpot = function(paperSpot, waterSpot){
      this.paperSpot = (paperSpot)? paperSpot.clone() : new PaperSpot();
      this.waterSpot = (waterSpot)? waterSpot.clone() : new WaterSpot();
    }

    CellSpot.prototype = (function(){
      /* private members */

      /* public members */
      return {
              clone: function(){ return new CellSpot(this.paperSpot, this.waterSpot); },
         addDroplet: function(drop){ this.waterSpot.addDroplet(drop); },
          stringify: function(){ return JSON.stringify(this); },
               copy: function(from){
                 this.paperSpot.copy(from.paperSpot);
                 this.waterSpot.copy(from.waterSpot);
               },
      };
    })();

    //------------
    // accept a list of { x: , y: , droplet: }
    // loop over the list, reset each cell and add to the cell.next (because reset happens before process)

    CAWorld.prototype.addDroplets = function(spotsWithCoords) {
      for (spot of spotsWithCoords) {
        var cell = this.grid[spot.y][spot.x];
        if (! cell) {
          console.log(`DEBUG: CAWorld.prototype.addDroplets: spot.x=${spot.x}, spot.y=${spot.y}, this.height=${this.height}, this.width=${this.width}`);
        }
        // cell.reset();
        var cellSpot = cell.next;
        cellSpot.addDroplet(spot.droplet);
        this.waterDropletsAddedToSurface.addDroplet(spot.droplet);
      }
    };

    //------------
    // accept a centre x,y of a drop of radius r, containing full WaterSpot of ink+water.
    // expand into a call to addDroplets

    CAWorld.prototype.addBigDrop = function(centreX, centreY, r, v) {
      const fromX = Math.floor( Math.max(centreX - r, 0));
      const   toX = Math.floor( Math.min(centreX + r, this.height-1));
      const fromY = Math.floor( Math.max(centreY - r, 0));
      const   toY = Math.floor( Math.min(centreY + r, this.width-1));

      const spotsWithCoords = [];

      // record any x,y that is within the radius of the centre
      for (var x=fromX; x<=toX; x++) {
        for (var y=fromY; y<=toY; y++) {
          const dx = x - centreX;
          const dy = y - centreY;

          if ((dx*dx + dy*dy) <= r*r) {
              spotsWithCoords.push({ x:x, y:y });
          }
        }
      }

      // assume waterSpot is divided equally between droplets
      const numDroplets = spotsWithCoords.length;
      const droplet = WaterSpot.createBigRandomDrop(v);

      spotsWithCoords.forEach(swc => {
        swc.droplet = droplet.clone();
      });

      this.addDroplets(spotsWithCoords);
    };

    //------------
    // add a stepCount

    CAWorld.prototype.stepWithCount = function() {
      if( !this.stepCount ){ this.stepCount = 0; }
      this.stepCount = this.stepCount + 1;
      this.stepThroughAllProcesses();
    };

    CAWorld.prototype.resetGrid = function() {
  		var y, x;
  		for (y=0; y<this.height; y++) {
  			for (x=0; x<this.width; x++) {
  				this.grid[y][x].reset();
  			}
  		}
    }

    CAWorld.prototype.addProcessTiming = function(name, timing) {
      if (! this.processTimings.hasOwnProperty(name)) {
        this.processTimings[name] = [];
      }

      this.processTimings[name].push(timing);
    }

    var neighborhood = [null, null, null, null, null, null, null, null];

    CAWorld.prototype.stepThroughProcess = function(processName) {
      {
        const startGridMillis = Date.now();
        this.resetGrid();
        const endGridMillis = Date.now();
        this.addProcessTiming('resetGrid', endGridMillis - startGridMillis);
      }
      {
        const startProcessMillis = Date.now();
    		// bottom up, left to right processing
    		for (y=this.height-1; y>=0; y--) {
    			for (x=this.width-1; x>=0; x--) {
    				this.fillNeighbors(neighborhood, x, y);
    				var cell = this.grid[y][x];
    				cell[processName](neighborhood);

    				// perform any delays
    				for (var i=0; i<cell.delays.length; i++) {
    					cell.delays[i].steps--;
    					if (cell.delays[i].steps <= 0) {
    						// perform action and remove delay
    						cell.delays[i].action(cell);
    						cell.delays.splice(i, 1);
    						i--;
    					}
    				}
    			}
    		}
        const endProcessMillis = Date.now();
        this.addProcessTiming(processName, endProcessMillis - startProcessMillis);
      }
  	};

    CAWorld.prototype.stepThroughAllProcesses = function() {

      this.Processes.forEach( name => {
        this.stepThroughProcess(name);
      });
    }

    CAWorld.ARBITRARY_MAX = 1000;
    CAWorld.DefaultConfig = {
      EvaporationFromPaperRate : {
              value : 0.001,
              range : [0, CAWorld.ARBITRARY_MAX],
        description : 'max amount of absorbed water which will evaporate from the paper',
      },
      EvaporationFromSurfaceRate : {
              value : 0.0005,
              range : [0, CAWorld.ARBITRARY_MAX],
        description : 'max amount of surface water which will evaoprate from the paper',
      },
      SpreadMinAmountToGoToDry : {
              value : 0.01,
              range : [0, CAWorld.ARBITRARY_MAX],
        description : "cell needs this min amount of surface water before spreading to a dry cell"
      },
      DownhillTipRatio : {
              value : 3,
              range : [1, CAWorld.ARBITRARY_MAX],
        description : "if there's a slope, the downhill SpreadMinAmountToGoToDry is multiplied by this factor"
      },
      DownhillTipRatioPartialDivisor : {
              value : Math.SQRT2,
              range : [1, CAWorld.ARBITRARY_MAX],
        description : "divide DownhillTipRatio by this factor for the corner nhrs"
      },
      ScaleForFlowToWet : {
              value : 1,
              range : [0, 2],
        description : "speed or slow the flow from wet to wet surface"
      },
      ScaleForFlowToDry : {
              value : 1,
              range : [0, 2],
        description : "speed or slow the flow from wet to dry surface"
      },
      PaperAbsorptionFactor : {
              value : 0.5,
              range : [0, 1],
        description : 'modify the water absorption rate across the whole paper'
      },
      PaperCapillaryFactor : {
              value : 1,
              range : [0, 1],
        description : 'modify the capillary flow rate across the whole paper'
      },
      PaperDiffusionFactor : {
              value : 0.5,
              range : [0, 1],
        description : 'modify the diffusion flow rate across the whole paper'
      },
      WaterDiffusionFactor : {
              value : 0.5,
              range : [0, 1],
        description : 'modify the diffusion flow rate across the whole paper surface'
      },
      WaterDiffusionFactor : {
              value : 0.5,
              range : [0, 1],
        description : 'modify the diffusion flow rate across the whole paper surface'
      },
      Processes : {
              value : ['absorption', 'surfaceFlow', 'capillaryFlow', 'diffusion', 'evaporation', 'sanityCheckValue'],
              known : ['absorption', 'surfaceFlow', 'capillaryFlow', 'diffusion', 'evaporation', 'sanityCheckValue'],
        description : 'the sequence of physical processes to run in turn on the grid',
      },
    };

    CAWorld.prototype.importConfig = function(config) {
      // create and load up this.config with the default values, and then override them as and when
      this.config = {};

      // loop over keys of DefaultConfig, looking for overrides in config,
      for( let key of Object.keys(CAWorld.DefaultConfig) ) {
        const details = CAWorld.DefaultConfig[key];
        if (details.hasOwnProperty('value')) {
          let value = details.value;

          if (config != undefined) {
            const newValue = config[key];
            if (newValue != undefined ) {
              if (details.range) {
                if (details.range[0] <= newValue && newValue <= details.range[1]) {
                  value = newValue;
                } else {
                  console.log(`WARNING: world: config: override value specified for ${key}, ${newValue}, falls outside of permitted range, ${details.range}`)
                }
              } else if (details.known) {
                const knownInNewValue = newValue.filter(v => { return details.known.includes(v) });
                if (knownInNewValue.length > 0) {
                  value = newValue;
                }
              }
            }
          }

          this.config[key] = value; // add to world config map, for documentation
          world[key]       = value; // push into world instance directly
        }
      }

      console.log(`world configs=${JSON.stringify(this.config, null, " ")}`);
    }

    //------------

    function createWorldOfBlottingPaperAndDyes(width, height, config={}) {
    	world = new CAWorld({
    		width: Math.floor(width),
    		height: Math.floor(height),
    	});

      world.directions = [world.LEFT, world.RIGHT, world.BOTTOM, world.TOP, world.TOPLEFT, world.TOPRIGHT, world.BOTTOMLEFT, world.BOTTOMRIGHT];
      // tracking loss/gain of substance (rather than moved between cells)
      world.waterSpotLost = new WaterSpot();
      world.waterEvaporationFromPaper   = new WaterSpot();
      world.waterEvaporationFromSurface = new WaterSpot();
      world.waterDropletsAddedToSurface = new WaterSpot(); // to be subtracted from the final totals

      // processname -> [timings]
      world.processTimings = {};

      world.importConfig( config );

    	world.registerCellType('paper', {
        getCellValue: function () {
          return this.value;
    		},
        getCellNextValue: function () {
          return this.next;
    		},
        sanityCheckValue: function() {
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          function thisError(msg){
            throw new Error(`ERROR: (${this.x}, ${this.y}): ${msg}`);
          }
          if (thisValuePaperSpot.waterAmount < 0) { thisError(`thisValuePaperSpot.waterAmount < 0, ${thisValuePaperSpot.waterAmount}`); }
          if (thisValueWaterSpot.waterAmount < 0) { thisError(`thisValueWaterSpot.waterAmount < 0, ${thisValueWaterSpot.waterAmount}`); }
          for (var d = 0; d < DYES.length; d++) {
            if (thisValuePaperSpot.dyeAmounts[d] < 0) { thisError(`thisValuePaperSpot.dyeAmounts[${d}]<0, ${thisValuePaperSpot.dyeAmounts[d]}`); }
            if (thisValueWaterSpot.dyeAmounts[d] < 0) { thisError(`thisValueWaterSpot.dyeAmounts[${d}]<0, ${thisValueWaterSpot.dyeAmounts[d]}`); }
          }
        },
        absorption: function (neighbors) {
          // - some of the current surface water (plus the associated dyes) get absorbed
          //    - capacity of paper
          //    - Rf for the dyes? Dyes get concentrated in remaining/reducing surface water?
          //    - some dyes get absorbed 'deeper' into the paper?

          const thisNextWaterSpot  = this.next.waterSpot;
          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          if (thisValueWaterSpot.waterAmount > 0) {
            const remainingPaperWaterCapacity = thisValuePaperSpot.MaxWaterCapacity - thisValuePaperSpot.waterAmount;
            if (remainingPaperWaterCapacity > 0) {
              const waterAmountToBeAbsorbed = Math.min(thisValueWaterSpot.waterAmount, thisValuePaperSpot.WaterAbsorptionRate, remainingPaperWaterCapacity) * world.PaperAbsorptionFactor;
              const proportionWaterAmountToBeAbsorbed = (waterAmountToBeAbsorbed / thisValueWaterSpot.waterAmount);
              // transfer water: add to paper, remove from water
              thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount + waterAmountToBeAbsorbed;
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - waterAmountToBeAbsorbed;

              // transfer dyes: add to paper, remove from water
              for (var d = 0; d < DYES.length; d++) {
                const flowProportion = (proportionWaterAmountToBeAbsorbed == 1)? 1 : proportionWaterAmountToBeAbsorbed * DYES[d].Rf;
                const flowAmount = flowProportion * thisValueWaterSpot.dyeAmounts[d];
                thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] + flowAmount;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] - flowAmount;
              }
            }
          }

          return true;
        },
    		surfaceFlow: function (neighbors) {
          // - remaining surface water can flow (and splodge) from/to here, taking into account
          //    - when both cells are wet, flow towards midpoint of water amounts
          //    - when both cells are dry, nothing happens
          //    - when one cell is wet, the other dry, the wet one flows into the dry one if there is a min amount
          //    - if there is a slope,
          //      the min amount is adjusted accordingly (down for downhill, up for uphill),
          //      the resultant water amounts are also adjusted (large for downhill)
          //    - dividing any amounts by 8
          //    - surface characteristics? could adjust the min height amount...
          //    - dyes flow in the same proportion as the water

          const thisNextWaterSpot  = this.next.waterSpot;
          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          function flowWithNhbr(direction, downhillTipRatio){
            // downhillTipRatio is factor when calculated from this cell.
            // -- to multiply world.SpreadMinAmountToGoToDry
            // -- Invert if from nhbr.
            // -- ==1 for level
            // -- >1 for here is downhill side
            // -- <1 for here is uphill sides
            // -- always > 0
            // return as soon as we work out no flow will happen

            const nhbr = neighbors[direction.index];
            let nhbrValueWaterSpot;
            let nhbrValueWaterSpotWaterAmount = 0;
            if (nhbr) {
              nhbrValueWaterSpot            = nhbr.value.waterSpot;
              nhbrValueWaterSpotWaterAmount = nhbrValueWaterSpot.waterAmount;
            }
            // skip if both cells are dry (including if there is no nhbr)
            if ((thisValueWaterSpot.waterAmount == 0) && (nhbrValueWaterSpotWaterAmount == 0)) {
              return;
            }

            // return if either nhbr is empty, and the other is not wet enough
            if (thisValueWaterSpot.waterAmount == 0) {
              if (nhbrValueWaterSpotWaterAmount <= (world.SpreadMinAmountToGoToDry * downhillTipRatio)) {
                return;
              }
            } else if (nhbrValueWaterSpotWaterAmount == 0) {
              if (thisValueWaterSpot.waterAmount <= (world.SpreadMinAmountToGoToDry / downhillTipRatio) ) {
                return;
              }
            }

            // assume that once the SpreadMinAmountToGoToDry threshold is breached,
            // water flows to the same levels as if both sides had started with water.

            // calc target amounts
            const totalAmounts = thisValueWaterSpot.waterAmount + nhbrValueWaterSpotWaterAmount;
            const thisTargetAmount = totalAmounts * downhillTipRatio / (downhillTipRatio + 1);
            const nhbrTargetAmount = totalAmounts * 1                / (downhillTipRatio + 1);
            const nhbrWaterDelta = nhbrTargetAmount - nhbrValueWaterSpotWaterAmount;  // +ve means from here, -ve from nhbr.

            const scaleForFlowToWetOrDry = (thisValueWaterSpot.waterAmount > 0 && nhbrValueWaterSpotWaterAmount > 0)? world.ScaleForFlowToWet : world.ScaleForFlowToDry;
            const waterAmountFlowing = nhbrWaterDelta * scaleForFlowToWetOrDry / 8;   // divided by 8 because is only one of 8 different here<->nhbr interactions.

            if (waterAmountFlowing == 0) {
              return;
            } else if (waterAmountFlowing > 0) { // from this cell to nhbr, so only record loss from this cell if there is no nhbr
              const proportionWaterAmountFlowing = waterAmountFlowing / thisValueWaterSpot.waterAmount;
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - waterAmountFlowing;
              if(!nhbr) { world.waterSpotLost.waterAmount = world.waterSpotLost.waterAmount + waterAmountFlowing; }

              // transfer dyes: in water
              for (var d = 0; d < DYES.length; d++) {
                const dyeAmountFlowing = thisValueWaterSpot.dyeAmounts[d] * proportionWaterAmountFlowing;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] - dyeAmountFlowing;
                if(!nhbr){ world.waterSpotLost.dyeAmounts[d] = world.waterSpotLost.dyeAmounts[d] + dyeAmountFlowing; }
              }
            } else { // waterAmountFlowing < 0, flowing from nhbr to this cell
              const waterAmountFlowingFromNhbr = - waterAmountFlowing;
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount + waterAmountFlowingFromNhbr;
              // transfer dyes: in water
              const proportionWaterAmountFlowing = waterAmountFlowingFromNhbr / nhbrValueWaterSpotWaterAmount;
              for (var d = 0; d < DYES.length; d++) {
                const dyeAmountFlowing = nhbrValueWaterSpot.dyeAmounts[d] * proportionWaterAmountFlowing;
                thisNextWaterSpot.dyeAmounts[d] = thisNextWaterSpot.dyeAmounts[d] + dyeAmountFlowing;
              }
            }
          }

          // assume
          // - LEFT+RIGHT flow does not feel effect of slope
          // - DOWN feels full effect slope
          // - UP feels inverse of full effect of slope
          // - DOWN LEFT+RIGHT feels partial effect of slope
          // - UP LEFT+RIGHT feels inverse of partial effect of slope

          const DownhillTipRatioPartial = world.DownhillTipRatio / world.DownhillTipRatioPartialDivisor;

          flowWithNhbr(world.LEFT       , 1                           );
          flowWithNhbr(world.RIGHT      , 1                           );
          flowWithNhbr(world.TOP        ,     world.DownhillTipRatio  ); // TOP is down
          flowWithNhbr(world.TOPLEFT    ,     DownhillTipRatioPartial );
          flowWithNhbr(world.TOPRIGHT   ,     DownhillTipRatioPartial );
          flowWithNhbr(world.BOTTOM     , 1 / world.DownhillTipRatio  ); // BOTTOM is up
          flowWithNhbr(world.BOTTOMLEFT , 1 / DownhillTipRatioPartial );
          flowWithNhbr(world.BOTTOMRIGHT, 1 / DownhillTipRatioPartial );

          return true;
        },
    		capillaryFlow: function (neighbors) {
          // -  water in paper will flow by capillary action, from high moisture to low
          //    - taking with it some dyes
          //    - only flows from/to a extant nhbr

          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          const remainingPaperWaterCapacity = thisValuePaperSpot.MaxWaterCapacity - thisValuePaperSpot.waterAmount;
          for (direction of world.directions) {
            let nhbr = neighbors[direction.index];
            if (!nhbr) { continue; }
            let nhbrValuePaperSpot = nhbr.value.paperSpot;
            let deltaWaterAmount = (thisValuePaperSpot.waterAmount - nhbrValuePaperSpot.waterAmount);
            let deltaWaterAmountScaled = deltaWaterAmount / (2 * 8);
            // +ve means from here, -ve from nhbr
            if (remainingPaperWaterCapacity > 0 && deltaWaterAmountScaled < 0) {
              let waterFlowAmount = Math.min(( - deltaWaterAmountScaled), remainingPaperWaterCapacity) * world.PaperCapillaryFactor;
              thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount + waterFlowAmount;
              let waterFlowProportion = waterFlowAmount / nhbrValuePaperSpot.waterAmount;
              for (var d = 0; d < DYES.length; d++) {
                let dyeFlowAmount = waterFlowProportion * DYES[d].Rf * nhbrValuePaperSpot.dyeAmounts[d];
                thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] + dyeFlowAmount;
              }
            } else if(deltaWaterAmountScaled > 0) {
              let nhbrRemainingPaperWaterCapacity = nhbrValuePaperSpot.MaxWaterCapacity - nhbrValuePaperSpot.waterAmount;
              if (nhbrRemainingPaperWaterCapacity > 0) {
                let waterFlowAmount = Math.min(deltaWaterAmountScaled, nhbrRemainingPaperWaterCapacity) * world.PaperCapillaryFactor;
                thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount - waterFlowAmount;
                let waterFlowProportion = waterFlowAmount / thisValuePaperSpot.waterAmount;
                for (var d = 0; d < DYES.length; d++) {
                  let dyeFlowAmount = waterFlowProportion * DYES[d].Rf * thisValuePaperSpot.dyeAmounts[d];
                  thisNextPaperSpot.dyeAmounts[d] = thisNextPaperSpot.dyeAmounts[d] - dyeFlowAmount;
                }
              }
            }

          }

          return true;
        },
    		diffusion: function (neighbors) {
          // - ink will diffuse, in wet paper
          //    - assume is related to relative concentrations, flowing from high to low (where both sides are wet)

          // within wet paper, and on wet surface
          for (let params of [
            // [spotType, diffusionFactor]
            ['paperSpot', world.PaperDiffusionFactor],
            ['waterSpot', world.WaterDiffusionFactor]
          ]) {

            const        spotType = params[0];
            const diffusionFactor = params[1];

            if (diffusionFactor <= 0) { continue; }

            const   thisValueSpot = this.value[spotType];
            const    thisNextSpot = this.next[spotType];

            if (thisValueSpot.waterAmount > 0) {
              for (direction of world.directions) {
                let nhbr = neighbors[direction.index];
                if (!nhbr) { continue; }
                let nhbrValueSpot = nhbr.value[spotType];
                if (nhbrValueSpot.waterAmount <= 0) { continue; }

                for (var d = 0; d < DYES.length; d++) {
                  let thisValueConcentration = thisValueSpot.dyeAmounts[d] / thisValueSpot.waterAmount;
                  let nhbrValueConcentration = nhbrValueSpot.dyeAmounts[d] / nhbrValueSpot.waterAmount;
                  let deltaConcentration = nhbrValueConcentration - thisValueConcentration;
                  if (deltaConcentration > 0) { // dye comes to here
                    let dyeFlowAmount = diffusionFactor * DYES[d].Rd * (deltaConcentration / nhbrValueConcentration) * nhbrValueSpot.dyeAmounts[d] / 8;
                    thisNextSpot.dyeAmounts[d] = thisNextSpot.dyeAmounts[d] + dyeFlowAmount;
                  } else if (deltaConcentration < 0) { // dye goes from here
                    let dyeFlowAmount = diffusionFactor * DYES[d].Rd * (deltaConcentration / thisValueConcentration) * thisValueSpot.dyeAmounts[d] / 8;
                    thisNextSpot.dyeAmounts[d] = thisNextSpot.dyeAmounts[d] + dyeFlowAmount;
                  }
                }
              }
            }
          }

          return true;
        },
    		evaporation: function (neighbors) {
          // - paper will dry out as water evaporates
          //    - assume will not evaporate from paper if water on surface
          //    - for simplicity, apply evaporation to computed Next, otherwise needs to be included in all other calculations
          //    - handle when there are dyes in surface water which fully evaporates

          const thisNextWaterSpot  = this.next.waterSpot;
          const thisNextPaperSpot  = this.next.paperSpot;
          const thisValueWaterSpot = this.value.waterSpot;
          const thisValuePaperSpot = this.value.paperSpot;

          if (thisValueWaterSpot.waterAmount > 0) {
            let evapAmount = Math.min(thisValueWaterSpot.waterAmount, world.EvaporationFromSurfaceRate);
            if (evapAmount > 0) {
              thisNextWaterSpot.waterAmount = thisNextWaterSpot.waterAmount - evapAmount;
              world.waterEvaporationFromSurface.waterAmount = world.waterEvaporationFromSurface.waterAmount + evapAmount;
              if (thisNextWaterSpot.waterAmount == 0) {
                thisNextPaperSpot.addDroplet(thisNextWaterSpot);
                thisNextWaterSpot.dyeAmounts.fill(0);
              }
            }
          }
          else
          if (thisValuePaperSpot.waterAmount > 0) {
            let evapAmount = Math.min(thisValuePaperSpot.waterAmount, world.EvaporationFromPaperRate);
            thisNextPaperSpot.waterAmount = thisNextPaperSpot.waterAmount - evapAmount;
            world.waterEvaporationFromPaper.waterAmount = world.waterEvaporationFromPaper.waterAmount + evapAmount;
          }

          return true;
        },
    		reset: function () {
          let oldPrev = this.prev; // don't discard the old value
  				this.prev   = this.value;
  				this.value  = this.next;
          this.next   = oldPrev;
          this.next.copy(this.value); // so adds and deletes happen in the .next value
    			return true;
    		}
    	}, function (x,y) {
    		//init
        this.value = new CellSpot();
        this.prev  = new CellSpot();
    		this.next  = new CellSpot();
        this.x = x;
        this.y = y;
    	});

    	world.initialize([
    		{ name: 'paper', distribution: 100 }
    	]);

    	return world;
    }

    //------------

    function writeWorldWaterAmountsToImageData(world, imageData){
      var worldGrid = world.grid;
      if ((imageData.width !== worldGrid.length) || (imageData.height !== worldGrid[0].length)) {
        throw new Error(`Error: mismatch found between size of grid and imageData`);
      }
      const data = imageData.data;
      for (var x=0; x<imageData.width; x++) {
        for (var y=0; y<imageData.height; y++) {
          const cellValue = worldGrid[y][x].getCellValue();
          var rgba = [
            (cellValue.waterSpot.waterAmount)*255,
            (cellValue.paperSpot.waterAmount) * 255,
            0,
            255
          ];
          var dataCellIndex = 4 * (x + (y * imageData.width));
          for (var i = 0; i < 4; i++) {
            data[dataCellIndex+i] = rgba[i];
          }
        }
      }
      return imageData;
    }

    //------------

    function convertWorldGridToGridOfDyeAmounts(world, spotType='paperSpot'){
      var worldGrid = world.grid;
      var gridOfDyeAmounts = [];

      // imageData reads from top left to bottom right
      // world reads from bottom left to top right (I think)

      for (var x = 0; x < world.width; x++) {
        var col = [];
        gridOfDyeAmounts.push(col);
        for (var y = 0; y < world.height; y++) {
          const cellValue = worldGrid[y][x].getCellValue();
          let dyeAmounts;
          if (spotType == 'paperSpot' || spotType == 'waterSpot') {
            dyeAmounts = cellValue[spotType].dyeAmounts;
          } else {
            dyeAmounts = DYES.cloneAmounts(cellValue.paperSpot.dyeAmounts);
            DYES.addAmounts(cellValue.waterSpot.dyeAmounts, dyeAmounts);
          }
          col.push( dyeAmounts );
        }
      }

      return gridOfDyeAmounts;
    }

    function calcDyeAndWaterTotalsInWorld(world){
      const worldGrid = world.grid;
      const dyeAmountsInPaper    = DYES.newEmptyDyeAmounts();
      const dyeAmountsInWater    = DYES.newEmptyDyeAmounts();
      let waterAmountInPaper   = 0;
      let waterAmountOnSurface = 0;

      for (var x = 0; x < world.width; x++) {
        for (var y = 0; y < world.height; y++) {
          let cell = worldGrid[y][x].getCellNextValue();
          DYES.addAmounts(cell.paperSpot.dyeAmounts, dyeAmountsInPaper);
          DYES.addAmounts(cell.waterSpot.dyeAmounts, dyeAmountsInWater);
          waterAmountInPaper   = waterAmountInPaper   + cell.paperSpot.waterAmount;
          waterAmountOnSurface = waterAmountOnSurface + cell.waterSpot.waterAmount;
        }
      }

      const dyeAmountsTotal = DYES.newEmptyDyeAmounts();
      DYES.addAmounts(dyeAmountsInPaper, dyeAmountsTotal);
      DYES.addAmounts(dyeAmountsInWater, dyeAmountsTotal);
      DYES.addAmounts(world.waterSpotLost.dyeAmounts, dyeAmountsTotal);
      DYES.subtractAmounts(world.waterDropletsAddedToSurface.dyeAmounts, dyeAmountsTotal);
      const dyeAmountTotal = dyeAmountsTotal.reduce( (prev, curr) => prev + curr );
      const waterAmountTotal = [
        waterAmountInPaper,
        waterAmountOnSurface,
        world.waterSpotLost.waterAmount,
        world.waterEvaporationFromPaper.waterAmount,
        world.waterEvaporationFromSurface.waterAmount
      ].reduce( (prev, curr) => prev + curr ) - world.waterDropletsAddedToSurface.waterAmount;

      return {
        waterAmountTotal    : waterAmountTotal,
        waterAmountInPaper  : waterAmountInPaper,
        waterAmountOnSurface: waterAmountOnSurface,
        waterAmountInPaperOrOnSurface: waterAmountInPaper + waterAmountOnSurface,
        waterAmountLost     : world.waterSpotLost.waterAmount,
        waterAmountEvaporationFromPaper   : world.waterEvaporationFromPaper.waterAmount,
        waterAmountEvaporationFromSurface : world.waterEvaporationFromSurface.waterAmount,
        waterDropletsAddedToSurface : world.waterDropletsAddedToSurface.waterAmount,
          dyeAmountTotal    :   dyeAmountTotal,
          dyeAmountsTotal   :   dyeAmountsTotal,
          dyeAmountsInPaper :   dyeAmountsInPaper,
          dyeAmountsInWater :   dyeAmountsInWater,
          dyeAmountsLost    : world.waterSpotLost.dyeAmounts,
                  stepCount : (world.stepCount === undefined)? 0 : world.stepCount,
      }
    }

    function calcDyeAndWaterTotalDelta(totalsList, relative=true){
      const first = (relative)? totalsList[totalsList.length - 2] : totalsList[0];
      const last  = totalsList[totalsList.length - 1];
      return {
          stepCountDelta : last.stepCount - first.stepCount + ((relative)? 0 : 1),
        waterAmountTotal : (last.waterAmountTotal - first.waterAmountTotal).toFixed(5),
          dyeAmountTotal : (last.dyeAmountTotal - first.dyeAmountTotal).toFixed(5),
      }
    }

    function calcAndDisplayTotals(iterationDetails, relative=true){
      let fromTimeMillis = (relative)? iterationDetails.startBatchRunTimeMillis : iterationDetails.startBatchRunTimeMillis;
      let fromIndex      = (relative && iterationDetails.totalsList.length > 2)? iterationDetails.totalsList.length - 2   : 0;

      let nowMillis = Date.now();
      let frameRate = iterationDetails.batchSize / ((nowMillis - fromTimeMillis) / 1000);
      let pixelRate = iterationDetails.batchSize * world.width * world.height / ((nowMillis - iterationDetails.startBatchRunTimeMillis) / 1000);
      let totals = calcDyeAndWaterTotalsInWorld(world);
      iterationDetails.totalsList.push(totals);
      if (iterationDetails.totalsList.length > 1) {
        const totalsDelta = calcDyeAndWaterTotalDelta(iterationDetails.totalsList, relative);
        if (Math.abs(totalsDelta.waterAmountTotal) > iterationDetails.minAcceptableDelta || Math.abs(totalsDelta.dyeAmountTotal) > iterationDetails.minAcceptableDelta) {
          console.log(`WARNING: delta error > ${iterationDetails.minAcceptableDelta}
            prev: ${JSON.stringify(iterationDetails.totalsList[fromIndex])}
            last: ${JSON.stringify(iterationDetails.totalsList[iterationDetails.totalsList.length - 1])}`);
            console.log(`       totalsDelta=${JSON.stringify(totalsDelta)}`);
        }
        if (relative) {
          iterationDetails.startBatchRunTimeMillis = nowMillis;
        }
      }
      console.log(`iteration=${iterationDetails.numIterations}, frames/s=${frameRate.toFixed(2)}, pixels/s=${pixelRate.toFixed(0)}, waterAmountRemaining=${totals.waterAmountInPaperOrOnSurface.toFixed(1)} (on surface: ${totals.waterAmountOnSurface.toFixed(1)})`);

      {
        const names = Object.keys(world.processTimings);

        const processTimings = names.map(name => {
          const timingsList = world.processTimings[name];
          const lastFew = timingsList.slice(- iterationDetails.batchSize);
          const avg = lastFew.reduce( (prev, curr) => prev + curr ) / lastFew.length;
          return `${name}: ${avg.toFixed(0)}`;
        });

        console.log(`process timings: ${processTimings.join(', ')}`);
      }
    }

    function addDrops(details){
      // addDrops({
      //   num : 1,
      //   xRange: [0, world.width],
      //   yRange: [0, world.height],
      //   rRange: [2, world.width/3],
      //   vRange: [10000, 10000]
      // });

      function randomWithinRange(range){
        return range[0] + (range[1] - range[0]) * Math.random();
      }

      for (var i = 0; i < details.num; i++) {
        world.addBigDrop(
          randomWithinRange(details.xRange),
          randomWithinRange(details.yRange),
          randomWithinRange(details.rRange),
          randomWithinRange(details.vRange)
        );
      }
    }

    // create a map of key/value pairs,
    // expanding any key==json into an obj, assuming it is a map, and folding its key/value pairs into the main map,
    // recording assorted info in the history.
    function parseUrlParams( queryString ) {
      const qsMinusQM = queryString.replace(/^\?/, '');
      const qsParamStrings = qsMinusQM.split(/&/);

      const configs = {};
      const history = {
        queryString : queryString,
          jsonList : [],
        };

      // look for all candidate configs,
      const candidateKeyValueMap = {};

      for (let paramString of qsParamStrings) {
        const match = paramString.match(/^([^=]+)=(.*)/);
        if (!match) {
          console.log(`parseUrlParams: could not parse ${paramString}`);
        } else {
          const name = match[1];
          const value = decodeURIComponent(match[2]);

          if (name == 'json') {
            const jsonObj = JSON.parse(value);
            Object.keys( jsonObj ).forEach(k => {
              candidateKeyValueMap[k] = jsonObj[k];
            });
            history.jsonList.push(value);
          } else {
            candidateKeyValueMap[name] = value;
          }
        }
      }

      const CombinedDefaultConfig = Object.assign({}, DefaultConfig, CAWorld.DefaultConfig);
      history['CombinedDefaultConfig'] = CombinedDefaultConfig;

      // loop over each CombinedDefaultConfig config and update configs if the candidate config key+value pass muster
      for (let key of Object.keys(CombinedDefaultConfig)) {
        let value = CombinedDefaultConfig[key].value;
        if (candidateKeyValueMap.hasOwnProperty(key)) {
          const candidateValue = candidateKeyValueMap[key];
          const details = CombinedDefaultConfig[key];

          let defaultValuetype = typeof details.value;
          if (defaultValuetype === 'boolean') {
            value = (candidateValue == 'true');
          } else if (defaultValuetype === 'number') {
            const parsed = parseFloat(candidateValue);
            if (isNaN(parsed) ) {
              console.log(`parseUrlParams: could not parse as a float: ${key}=${candidateValue}`);
            } else {
              if (details.range) {
                if (parsed < details.range[0] || parsed > details.range[1]) {
                  console.log(`parseUrlParams: out of range, ${details.range}: ${key}=${candidateValue}`);
                } else {
                  value = parsed;
                }
              }
            }
          } else if (Array.isArray(details.value)) {
            const parsed = JSON.parse(candidateValue);
            if (!Array.isArray(parsed)) {
              console.log(`parseUrlParams: not an array: ${key}=${candidateValue}`);
            } else {
              if (details.known) {
                const knownInNewValue = parsed.filter(v => { return details.known.includes(v) });
                if (knownInNewValue.length != parsed.length) {
                  console.log(`parseUrlParams: contains unrecognised values, ${details.known}: ${key}=${candidateValue}`);
                } else {
                  value = parsed;
                }
              } else if (details.type == 'range') {
                if (parsed.length != 2) {
                  console.log(`parseUrlParams: should be a range consisting of two values: ${key}=${candidateValue}`);
                } else {
                  const anyNaNs = parsed.filter( n => {return isNaN(n);} );
                  if (anyNaNs.length > 0) {
                    console.log(`parseUrlParams: could not parse as two floats: ${key}=${candidateValue}`);
                  } else if (parsed[0] > parsed[1]) {
                    console.log(`parseUrlParams: floats should be in ascending order: ${key}=${candidateValue}`);
                  } else if (details.range){
                    const anyOutOfRange = parsed.filter( n => {
                      return (n < details.range[0] || n > details.range[1]);
                    } );
                    if (anyOutOfRange.length > 0) {
                      console.log(`parseUrlParams: floats should be in range, ${details.range}: ${key}=${candidateValue}`);
                    } else {
                      value = parsed;
                    }
                  }
                }
              } else {
                value = parsed;
              }
            }
          } else if (details.known) {
            if (! details.known.includes(candidateValue) ) {
              console.log(`parseUrlParams: unrecognised value, ${details.known}: ${key}=${candidateValue}`);
            } else {
              value = candidateValue;
            }
          }
        }
        configs[ key ] = value;
      }

      const unrecognisedKeys = Object.keys(candidateKeyValueMap).filter( k => { return ! CombinedDefaultConfig.hasOwnProperty(k); });
      if (unrecognisedKeys.length > 0) {
        console.log(`parseUrlParams: contains unrecognised keys: ${unrecognisedKeys}`);
      }

      configs['history'] = history;

      return configs;
    }

    const ARBITRARY_MAX = 1000;
    const DefaultConfig = {
      size: {
              value : 100,
              range : [1, ARBITRARY_MAX],
        description : 'dimensions of square canvas & grid',
      },
      maxIterations: {
              value : 2000,
              range : [0, 10*ARBITRARY_MAX],
        description : 'upper limit for iteration, assuming there is still water in or on the paper',
      },
      record: {
              value : false,
        description : 'to record the canvas animation as a webm file',
      },
      dropsNum: {
              value : 10,
              range : [0, ARBITRARY_MAX],
        description : 'how many initial drops',
      },
      dropsXRange: {
              value : [0, 1],
              range : [0, 2],
               type : 'range',
        description : 'min/max of x as a proportion of world.width',
      },
      dropsYRange: {
              value : [0, 1],
              range : [0, 2],
               type : 'range',
        description : 'min/max of y as a proportion of world.width',
      },
      dropsRRange: {
              value : [0, 1/3],
              range : [0, 2],
               type : 'range',
        description : 'min/max of r as a proportion of the world.width (with an unbreakable minimum of 2 cells)',
      },
      dropsVRange: {
              value : [1, 3],
              range : [0, 10*ARBITRARY_MAX],
               type : 'range',
        description : 'min/max of volume as a proportion of world.width',
      },
      spotType: {
              value : 'cellSpot',
              known : ['cellSpot', 'waterSpot', 'paperSpot'],
        description : 'which source to use for dyeAmounts when generating the view',
      },
      viewType: {
              value : 'dyeAmounts',
              known : ['dyeAmounts', 'waterAmounts'],
        description : 'which type of source when generating the view',
      },
    };

    function startRecording( canvas, codeVersion ){
      /* set up the recording of the canvas animations */
      const mimeType = 'video/webm'; // couldn't find a different format which worked, e.g. mp4.
      const options = {mimeType: mimeType};
      const recordedFile = `chromatography-experiment.${codeVersion}.webm`;
      function download(event) { // receives the recorded data, and writes to file using a url hack. Ick.
        const videoData = [ event.data ];
        const blob = new Blob(videoData, {
          type: mimeType
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        document.body.appendChild(a);
        a.style = 'display: none';
        a.href = url;
        a.download = recordedFile;
        a.click();
        window.URL.revokeObjectURL(url);
      }
      const frameRate = 15;
      const stream = canvas.captureStream(frameRate);
      const mediaRecorder = new MediaRecorder(stream, options);
      mediaRecorder.ondataavailable = download;
      mediaRecorder.start();
      window.addEventListener('StopRecording', e => { mediaRecorder.stop(); })
    }

    function createPaper(canvas, queryString){
      const configs = parseUrlParams(queryString);
      console.log(`all configs: ${JSON.stringify(configs, null, ' ')}`);
      if (configs['size'] && configs['size'] > 1) {
        canvas.setAttribute('height', configs['size']);
        canvas.setAttribute( 'width', configs['size']);
      }

      if (configs.record) { startRecording( canvas, '3-0'); }

      function createPaperAddDropsAndRun() {
        const context = canvas.getContext('2d');
        console.log(`canvas.width=${canvas.width}, canvas.height=${canvas.height}`);
        const imageData = context.getImageData(0,0,canvas.width,canvas.height);
        const world = createWorldOfBlottingPaperAndDyes(imageData.width, imageData.height, configs);

        const iterationDetails = {
                      numIterations : 1,
                      maxIterations : configs.maxIterations,
                          batchSize : 10,
          startOverallRunTimeMillis : Date.now(),
            startBatchRunTimeMillis : Date.now(),
                 minAcceptableDelta : 0.1,
                         totalsList : [calcDyeAndWaterTotalsInWorld(world)],
        };

        console.log(`iteration=0,`);

        function iterateAndDisplayWorld(){
          world.stepWithCount();

          {
            const startDisplayMillis = Date.now();
            if (configs['viewType'] == 'dyeAmounts') {
              let gridOfDyeAmounts = convertWorldGridToGridOfDyeAmounts(world, configs['spotType']);
              DYES.writeGridOfDyeAmountsToImageData(gridOfDyeAmounts, imageData);
            } else if (configs['viewType'] == 'waterAmounts') {
              writeWorldWaterAmountsToImageData(world, imageData);
            }
            context.putImageData(imageData, 0, 0);
            const endDisplayMillis = Date.now();
            world.addProcessTiming('gridToImageData', endDisplayMillis - startDisplayMillis);
          }

          const relative = true;

          if ((iterationDetails.numIterations % iterationDetails.batchSize == 0) || iterationDetails.numIterations==1 ) {
            calcAndDisplayTotals(iterationDetails, relative);
          }

          iterationDetails.numIterations = iterationDetails.numIterations + 1;
          const lastTotals = iterationDetails.totalsList[iterationDetails.totalsList.length -1];
          const waterRemaining = lastTotals.waterAmountInPaper + lastTotals.waterAmountOnSurface;
          if (   (iterationDetails.numIterations >= iterationDetails.maxIterations)
              || ((iterationDetails.numIterations > iterationDetails.batchSize) && (waterRemaining <= 0))
            ) {
              calcAndDisplayTotals(iterationDetails, !relative);
              console.log(`iterations ended.`);
              window.dispatchEvent( new Event('StopRecording') );
          } else {
            window.requestAnimationFrame(iterateAndDisplayWorld);
          }
        }

        addDrops({
             num : configs.dropsNum,
          xRange : configs.dropsXRange.map(n => {return n * world.width ;}),
          yRange : configs.dropsYRange.map(n => {return n * world.height;}),
          rRange : configs.dropsRRange.map(n => {return n * world.width ;}),
          vRange : configs.dropsVRange
        });

        iterateAndDisplayWorld();
      }

      return {
        run: createPaperAddDropsAndRun
      }
    }

    return {
      createPaper: createPaper
    }
  })();
  </script>
</head>

<body>
  <h1>Chromatography</h1>

    <canvas class="blotting-paper" id="myCanvas" width="100" height="100"></canvas>

  <script>
  (function(){
    const canvas = document.getElementById('myCanvas');
    var paper = Chroma.createPaper(canvas, location.search);
    window.setTimeout(paper.run, 100);
  })();
  </script>
</body>
</html>
